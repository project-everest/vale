include "PPC64LE.Vale.InsBasic.vaf"
include "PPC64LE.Vale.InsMem.vaf"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Words.Two_s"
include{:fstar}{:open} "Words.Four_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "PPC64LE.Machine_s"
include{:fstar}{:open} "PPC64LE.Vale.State"
include{:fstar}{:open} "PPC64LE.Vale.Decls"

module PPC64LE.Vale.InsVector

#verbatim{:interface}
open FStar.Mul
open Words_s
open Words.Two_s
open Words.Four_s
open Types_s
open PPC64LE.Machine_s
open PPC64LE.Vale.State
open PPC64LE.Vale.Decls
open PPC64LE.Vale.InsBasic
open PPC64LE.Vale.InsMem

// Annoying type problem workaround
let nat64_to_nat32 (n:nat64 { n < pow2_32 }) : nat32 = let m:nat = n in m
#endverbatim

function nat64_to_nat32 (n:nat64) : nat32
  requires n < pow2_32;
  extern;

#verbatim
open Types_s
open PPC64LE.Machine_s
open PPC64LE.Vale
open PPC64LE.Vale.State
open PPC64LE.Vale.Decls
friend PPC64LE.Vale.Decls
module S = PPC64LE.Semantics_s
#endverbatim

var v0:quad32 {:state vec(0)};
var v1:quad32 {:state vec(1)};
var v2:quad32 {:state vec(2)};
var v3:quad32 {:state vec(3)};
var v4:quad32 {:state vec(4)};
var v5:quad32 {:state vec(5)};
var v6:quad32 {:state vec(6)};
var v7:quad32 {:state vec(7)};
var v8:quad32 {:state vec(8)};
var v9:quad32 {:state vec(9)};
var v10:quad32 {:state vec(10)};
var v11:quad32 {:state vec(11)};
var v12:quad32 {:state vec(12)};
var v13:quad32 {:state vec(13)};
var v14:quad32 {:state vec(14)};
var v15:quad32 {:state vec(15)};
var v16:quad32 {:state vec(16)};
var v17:quad32 {:state vec(17)};
var v18:quad32 {:state vec(18)};
var v19:quad32 {:state vec(19)};
var v20:quad32 {:state vec(20)};
var v21:quad32 {:state vec(21)};
var v22:quad32 {:state vec(22)};
var v23:quad32 {:state vec(23)};
var v24:quad32 {:state vec(24)};
var v25:quad32 {:state vec(25)};
var v26:quad32 {:state vec(26)};
var v27:quad32 {:state vec(27)};
var v28:quad32 {:state vec(28)};
var v29:quad32 {:state vec(29)};
var v30:quad32 {:state vec(30)};
var v31:quad32 {:state vec(31)};

// Operands of vector registers
operand_type vec_opr:quad32 :=
| inout v0 | inout v1 | inout v2 | inout v3
| inout v4 | inout v5 | inout v6 | inout v7
| inout v8 | inout v9 | inout v10 | inout v11
| inout v12 | inout v13 | inout v14 | inout v15
| inout v16 | inout v17 | inout v18 | inout v19
| inout v20 | inout v21 | inout v22 | inout v23
| inout v24 | inout v25 | inout v26 | inout v27
| inout v28 | inout v29 | inout v30 | inout v31
;

// Move high 64-bit of vector register to general-purpose register
procedure Mfvsrd(out dst:reg_opr, in src:vec_opr)
    {:public}
    {:instruction Ins(S.Mfvsrd(dst, src))}
    ensures
        dst == hi64(src);
{
}

// Move low 64-bit of vector register to general-purpose register
procedure Mfvsrld(out dst:reg_opr, in src:vec_opr)
    {:public}
    {:instruction Ins(S.Mfvsrld(dst, src))}
    ensures
        dst == lo64(src);
{
}

// Move joint of two general-purpose registers to vector register
procedure Mtvsrdd(out dst:vec_opr, in src1:reg_opr, in src2:reg_opr)
    {:public}
    {:instruction Ins(S.Mtvsrdd(dst, src1, src2))}
    ensures
        pow2_32 * dst.hi3 + dst.hi2 == old(src1);
        pow2_32 * dst.lo1 + dst.lo0 == old(src2);
{
}

// XOR operation of two vector registers
procedure Vxor(out dst:vec_opr, in src1:vec_opr, in src2:vec_opr)
    {:public}
    {:instruction Ins(S.Vxor(dst, src1, src2))}
    ensures
        dst == old(quad32_xor(src1, src2));
{
}

// Shift left word elements of vector register with correspinding bit values in word elements of vector register
procedure Vslw(out dst:vec_opr, in src1:vec_opr, in src2:vec_opr)
    {:public}
    {:instruction Ins(S.Vslw(dst, src1, src2))}
    ensures
        dst == old(Mkfour(
            ishl32(src1.lo0, src2.lo0 % 32),
            ishl32(src1.lo1, src2.lo1 % 32),
            ishl32(src1.hi2, src2.hi2 % 32),
            ishl32(src1.hi3, src2.hi3 % 32)));
{
}

// Shift right word elements of vector register with corresponding bit values in word elements of vector register
procedure Vsrw(out dst:vec_opr, in src1:vec_opr, in src2:vec_opr)
    {:public}
    {:instruction Ins(S.Vsrw(dst, src1, src2))}
    ensures
        dst == old(Mkfour(
            ishr32(src1.lo0, src2.lo0 % 32),
            ishr32(src1.lo1, src2.lo1 % 32),
            ishr32(src1.hi2, src2.hi2 % 32),
            ishr32(src1.hi3, src2.hi3 % 32)));
{
}

//  Compare equal word elements of vector register and store either ones or zeros in the corresponding elements of destination register
procedure Vcmpequw(out dst:vec_opr, in src1:vec_opr, in src2:vec_opr)
    {:public}
    {:instruction Ins(S.Vcmpequw(dst, src1, src2))}
    ensures
        dst == old(Mkfour(
            if src1.lo0 = src2.lo0 then 0xFFFFFFFF else 0,
            if src1.lo1 = src2.lo1 then 0xFFFFFFFF else 0,
            if src1.hi2 = src2.hi2 then 0xFFFFFFFF else 0,
            if src1.hi3 = src2.hi3 then 0xFFFFFFFF else 0));
{
}

// Joint of last one word of vector register with first 3 words of vector register
procedure Vsldoi(out dst:vec_opr, in src1:vec_opr, in src2:vec_opr, inline count:quad32bytes)
    {:public}
    {:instruction Ins(S.Vsldoi(dst, src1, src2, count))}
    requires
        count == 4 || count == 8 || count == 12;
    ensures
        count == 4 ==> dst == old(Mkfour(src2.hi3, src1.lo0, src1.lo1, src1.hi2));
        count == 8 ==> dst == old(Mkfour(src2.hi2, src2.hi3, src1.lo0, src1.lo1));
        count == 12 ==> dst == old(Mkfour(src2.lo1, src2.hi2, src2.hi3, src1.lo0));
{
}
