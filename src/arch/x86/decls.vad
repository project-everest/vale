include{:verbatim} "vale.i.dfy"
include{:verbatim}{:from BASE} "lib/util/dafny_wrappers.i.dfy"
include{:verbatim}{:from BASE} "lib/util/words_and_bytes.i.dfy"
include{:verbatim}{:from BASE} "lib/util/operations.i.dfy"

#verbatim
module x86_decls_i {

import opened declsX86vale = x86_vale_i
import opened x86_decls_i_parser_help_i = dafny_wrappers_i
import opened words_and_bytes_i_temp = words_and_bytes_i
import opened operations_i_temp = operations_i
#endverbatim

var{:state ok()} ok:bool;
var{:state reg(X86Eax)} eax:uint32;
var{:state reg(X86Ebx)} ebx:uint32;
var{:state reg(X86Ecx)} ecx:uint32;
var{:state reg(X86Edx)} edx:uint32;
var{:state reg(X86Esi)} esi:uint32;
var{:state reg(X86Edi)} edi:uint32;
var{:state reg(X86Ebp)} ebp:uint32;
var{:state Quadword(0)} xmm0:Quadword;
var{:state Quadword(1)} xmm1:Quadword;
var{:state Quadword(2)} xmm2:Quadword;
var{:state Quadword(3)} xmm3:Quadword;
var{:state Quadword(4)} xmm4:Quadword;
var{:state Quadword(5)} xmm5:Quadword;
var{:state flags()} efl:uint32;
var{:state mem()}   mem:Heaplets;
var{:state memory()}memory:heap;
var{:state stack()} stack:Stack;

#verbatim
function MaybeUpdateOk(s:State, r:State) : State
{
    if !(s.ok && r.ok) then s.(ok := false) else r
}
#endverbatim

procedure {:refined} {:instruction Ins(Mov32(dst, MakeHeapOp(src, offset, taint))) } 
          Load(out dst:opr32, src:opr32, inline offset:int, 
               inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidSrcAddr(mem, id, src + offset, 32, taint);
    reads
        mem;
    ensures
        dst == mem[id].words[src + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure {:refined} {:instruction Ins(Mov32(MakeHeapOp(dst, offset, taint), src)) } 
          Store(dst:opr32, src:opr32, inline offset:int, 
                inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidDstAddr(mem, id, dst + offset, 32);
    modifies
        mem;
    ensures
        mem == old(mem)[id := old(mem)[id].(words := old(mem)[id].words[dst + offset := WordHeapletEntry(src, taint)])];
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    ghost var v := old(src);

    ghost if (old(this).ok) { 
        ghost if (exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 32)) {
            exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 32);
            this := this.(heaplets := UpdateHeaplets(old(this), dst + offset, id, taint, v));
            lemma_HeapletsUpdatedCorrectly32(old(this), this, dst + offset, id, taint, v);
        } else {
            this := old(this).(ok := false);
        }
    } else {
      this := old(this);
    }
    this := MaybeUpdateOk(old(this), this);

    lemma_WordToBytes_BytesToWord_inverses(v);
}

procedure {:refined} {:instruction Ins(Mov32(dst, stack(slot))) } 
          LoadStack(out dst:opr32, inline slot:int)
    requires/ensures
        HasStackSlot(stack, slot);
    reads
        stack;
    ensures
        dst == stack[0][slot];
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure {:refined} {:instruction Ins(Mov32(stack(slot), src)) } 
          StoreStack(inline slot:int, src:opr32)
    requires/ensures
        HasStackSlot(stack, slot);
    modifies
        stack;
    ensures
        stack[0] == old(stack[0][slot := src]);
        SeqTail(stack, 1) == old(SeqTail(stack, 1));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}

procedure{:refined}{:instruction Ins(Add32(dst, OConst(1)))} incr(inout dst:opr32)
  requires
    0 <= dst <= 1000;
  modifies 
    efl;
  ensures
    dst == old(dst) + 1;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure{:refined}{:instruction Ins(Add32(dst, src))} Add32(inout dst:opr32, src:opr32)
  requires
    src + dst < 0x1_0000_0000;
  modifies 
    efl;
  ensures
    dst == old(dst) + old(src);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
    lemma_BitwiseAdd32EquivalentToAddMod2To32(old(dst), old(src));
}

procedure{:refined}{:instruction Ins(Add32(dst, src))} Add32Wrap(inout dst:opr32, src:opr32)
  modifies 
    efl;
  ensures
    dst == (old(dst) + old(src)) % 0x1_0000_0000;
    dst == old(BitwiseAdd32(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
    lemma_BitwiseAdd32EquivalentToAddMod2To32(old(dst), old(src));
}

procedure{:refined}{:instruction Ins(Mov32(dst, src))} Mov32(inout dst:opr32, src:opr32)
  ensures
    dst == old(src);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(BSwap32(dst))} BSwap32(inout dst:opr32)
  ensures
    dst == bswap32(old(dst));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined}  LoadBSwap(out dst:opr32, src:opr32, inline offset:int, 
                                inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidSrcAddr(mem, id, src + offset, 32, taint);
    reads
        mem;
    ensures
        dst == bswap32(mem[id].words[src + offset].v);
{
    Load(dst, src, offset, taint, id);
    BSwap32(dst);
}

/*

procedure MovBSwap32(out dst:opr, src:opr)
  requires/ensures
    x86_ValidState(this);
  requires
    x86_Valid32BitSourceOperand(this, @src);
    x86_Valid32BitDestinationOperand(this, @dst);
    RegOperand(@dst);
  ensures
    x86_evalUpdateAndMaintainFlags(old(this), @dst, bswap32(old(src)), this);
{
     Mov32(dst, src);
     BSwap32(dst);
}
*/

procedure {:refined} {:instruction Ins(Xor32(dst, src))} Xor32(inout dst:opr32, src:opr32)
  modifies efl;
  ensures
    dst == xor32(old(dst), old(src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(And32(dst, src))} And32(inout dst:opr32, src:opr32)
  modifies efl;
  ensures
    dst == and32(old(dst), old(src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(Not32(dst))} Not32(inout dst:opr32)
  modifies efl;
  ensures
    dst == not32(old(dst));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(Rol32(dst, OConst(amount)))} Rol32(inout dst:opr32, inline amount:uint32)
  requires 
    0 <= amount < 32;
  modifies efl;
  ensures
    dst == rol32(old(dst), old(amount));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(Ror32(dst, OConst(amount)))} Ror32(inout dst:opr32, inline amount:uint32)
  requires 
    0 <= amount < 32;
  modifies efl;
  ensures
    dst == ror32(old(dst), old(amount));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(Shl32(dst, OConst(amount)))} Shl32(inout dst:opr32, inline amount:uint32)
  requires 
    0 <= amount < 32;
  modifies efl;
  ensures
    dst == shl32(old(dst), old(amount));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(Shr32(dst, OConst(amount)))} Shr32(inout dst:opr32, inline amount:uint32)
  requires 
    0 <= amount < 32;
  modifies efl;
  ensures
    dst == shr32(old(dst), old(amount));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}


/*

procedure{:instruction Ins(AddCarry(dst, src))} AddCarry(inout dst:opr, src:opr)
  requires/ensures
    x86_ValidState(this);
    x86_Valid32BitSourceOperand(this, @dst);
  requires
    x86_Valid32BitSourceOperand(this, @src);
    x86_Valid32BitDestinationOperand(this, @dst);
  ensures
    ValidInstruction(to_state(old(this)), AddCarry(to_operand(@dst), to_operand(@src)));
    x86_evalUpdateAndHavocFlags(old(this), @dst, AddCarrySum(old(dst), old(src), old(this.flags)) % 0x1_0000_0000, this);
    Cf(this.flags) ==  AddCarrySum(old(dst), old(src), old(this.flags)) >= 0x1_0000_0000;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal valid_state;
    reveal Has;
    reveal Get;
    ghost var v := AddCarrySum(old(dst), old(src), old(this.flags)) % 0x1_0000_0000;
    lemma_WordToBytes_BytesToWord_inverses(v);
    this := this.(heaplets := UpdateHeaplets(old(this), @dst, v));
    lemma_HeapletsUpdatedCorrectly32(old(this), this, @dst, v);
}

procedure{:instruction Ins(GetCf(dst))} GetCf(out dst:opr)
  requires/ensures
    x86_ValidState(this);
    x86_Valid32BitSourceOperand(this, @dst);
  requires
    x86_Valid32BitDestinationOperand(this, @dst);
    0 <= dst < 256;
  ensures 
    ValidInstruction(to_state(old(this)), GetCf(to_operand(@dst)));
    x86_evalUpdateAndMaintainFlags(old(this), @dst, clear_low_byte(old(dst)) + CarryBit(old(this.flags)), this);
    //ensures  dst == CarryBit(old(this.flags));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal valid_state;
    reveal Has;
    reveal Get;
    ghost var v := if Cf(old(this).flags) then 1 else 0;
    lemma_WordToBytes_BytesToWord_inverses(v);
    this := this.(heaplets := UpdateHeaplets(old(this), @dst, v));
    lemma_HeapletsUpdatedCorrectly32(old(this), this, @dst, v);
}
*/

procedure {:refined} {:instruction Ins(Pxor(dst, src))} Pxor(inout dst:opr_quad, src:opr_quad)
  modifies efl;
  ensures
    dst == old(QuadwordXor(dst, src));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

/*

procedure {:instruction Ins(MOVDQU(dst, src))} MOVDQU(inout dst:opr, src:opr)
  requires/ensures
    x86_ValidState(this);
    x86_Valid128BitDestinationOperand(this, @dst);
    x86_Valid128BitSourceOperand(this, @src);
    !(to_operand(@src) is OConst);
    IsXmmOperand(to_operand(@dst)) || IsXmmOperand(to_operand(@src));
  ensures
    ValidInstruction(to_state(old(this)), MOVDQU(to_operand(@dst), to_operand(@src)));
    x86_evalUpdate128AndHavocFlags(old(this), @dst, old(Eval128BitOperand(to_state(this), to_operand(@src))), this, x86_insObservations(old(this), Ins(MOVDQU(to_operand(@dst), to_operand(@src)))));
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    reveal valid_state;
    reveal Has;
    reveal Get;

    ghost var v := old(Eval128BitOperand(to_state(this), to_operand(@src)));
    lemma_WordToBytes_BytesToWord_inverses(v.lo);
    lemma_WordToBytes_BytesToWord_inverses(v.mid_lo);
    lemma_WordToBytes_BytesToWord_inverses(v.mid_hi);
    lemma_WordToBytes_BytesToWord_inverses(v.hi);
    this := this.(heaplets := UpdateHeaplets128(old(this), @dst, v));
    lemma_HeapletsUpdatedCorrectly128(old(this), this, @dst, v);
}
*/

procedure{:refined}{:instruction Ins(MOVDQU(dst, src))} Mov128(inout dst:opr_quad, src:opr_quad)
  modifies
    efl;
  ensures
    dst == old(src);
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := MaybeUpdateOk(old(this), this);
    this := this.(heaplets := old(this).heaplets);
}

procedure {:refined} {:instruction Ins(MOVDQU(dst, MakeHeapOp(src, offset, taint))) } 
          Load128(out dst:opr_quad, src:opr32, inline offset:int, 
                  inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidSrcAddr(mem, id, src + offset, 128, taint);
    reads mem;
    modifies efl;
    ensures
        dst == mem[id].quads[src + offset].v;
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    this := this.(heaplets := old(this).heaplets);
    this := MaybeUpdateOk(old(this), this);
}


procedure {:refined} {:instruction Ins(MOVDQU(MakeHeapOp(dst, offset, taint), src)) } 
          Store128(dst:opr32, src:opr_quad, inline offset:int, 
                   inline taint:taint, ghost id:heaplet_id)
    requires/ensures
        ValidDstAddr(mem, id, dst + offset, 128);
    modifies
        mem; efl;
    ensures
        mem == old(mem)[id := old(mem)[id].(quads := old(mem)[id].quads[dst + offset := QuadwordHeapletEntry(src, taint)])];
{
    reveal evalCodeOpaque;
    reveal x86_ValidState;
    ghost var v := old(src);

    ghost if (old(this).ok) { 
        ghost if (exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 128)) {
            exists id :: ValidDstAddr(old(this).heaplets, id, old(dst) + offset, 128);
            this := this.(heaplets := UpdateHeaplets128(old(this), dst + offset, id, taint, v));
            lemma_HeapletsUpdatedCorrectly128(old(this), this, dst + offset, id, taint, v);
        } else {
            this := old(this).(ok := false);
        }
    } else {
      this := old(this);
    }
    this := MaybeUpdateOk(old(this), this);

    //lemma_WordToBytes_BytesToWord_inverses(v);
}

#verbatim
} // end module x86decls
#endverbatim
