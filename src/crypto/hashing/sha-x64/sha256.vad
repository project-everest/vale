include "../../../arch/x64/decls.vad"
include{:verbatim} "../../../arch/x64/vale.i.dfy"
include{:verbatim} "../../../arch/x64/print.s.dfy"
include{:verbatim} "../sha256.i.dfy"
include{:verbatim} "../../../lib/util/heaplets64.i.dfy"

#verbatim
module x64_sha256_vale {

import opened x64_def_s
import opened x64_vale_i
import opened x64_print_s
import opened x64_decls_i
import opened sha256_i
import opened heaplets_i
import opened operations_i
#endverbatim

#token += precedence :=
#token &= precedence :=
#token ^= precedence :=
#token ~= precedence :=

procedure operator(:=) (out operand dst:int, operand src:int) := Mov32;
procedure operator(+=) (inout operand dst:int, operand src:int) := Add32Wrap;
procedure operator(&=) (inout operand dst:int, operand src:int) := And32;
procedure operator(^=) (inout operand dst:int, operand src:int) := Xor32;
procedure operator(~=) (inout operand dst:int) := Not32;   // Usage awaits the ability to say: edx ~= edx.

procedure {:refined} {:timeLimitMultiplier 2} ComputeOneStep_SHA256_core(
  inline offset:uint32,
  inline K:uint32,    // Round constant
  inline W_offset:uint32,
  inline W_taint:taint,
  ghost W_id:heaplet_id,
  ghost atoh:atoh_Type,
  ghost z:SHA256Trace,
  ghost currentStep:uint32, 
  ghost currentState:SHA256_state
) returns (
  ghost final_atoh:atoh_Type,
  ghost final_z:SHA256Trace
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
  requires/ensures
    // Vale requirements
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddr(mem, W_id, r9 + W_offset, 32, W_taint);
  requires
    offset == 0 || offset == 7;

    // SHA requirements
    SeqLength(z.H) > 0;
    currentStep <= 63;
    K == K_SHA256(currentStep); 
    atoh == atoh_c(r11d,
                   stack[0][9 + offset + 0],
                   stack[0][9 + offset + 1],
                   stack[0][9 + offset + 2],
                   stack[0][9 + offset + 3],
                   stack[0][9 + offset + 4],
                   stack[0][9 + offset + 5],
                   stack[0][9 + offset + 6]);
    currentState.atoh == atoh;
    0 <= currentStep < SeqLength(currentState.W) && currentState.W[currentStep] == mem[W_id].words[r9 + W_offset].v;
    IsSHA256ReadyForStep(z, currentState, currentStep);
  reads
    mem; r9;
  modifies
    efl; stack; eax; r8d; ecx; edx; r10d; r11d;
  ensures
    // SHA postconditions
    final_atoh == atoh_c(r11d,
                         stack[0][9 + 7 - offset],
                         stack[0][9 + 8 - offset],
                         stack[0][9 + 9 - offset],
                         stack[0][9 + 10 - offset],
                         stack[0][9 + 11 - offset],
                         stack[0][9 + 12 - offset],
                         stack[0][9 + 13 - offset]);
    IsSHA256ReadyForStep(final_z, currentState.(atoh := final_atoh), currentStep+1);
    SeqLength(final_z.H) == SeqLength(z.H);
    final_z.M == z.M;
    // Framing
    forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
    forall slot :: HasStackSlot(stack, slot) && HasStackSlot(old(stack), slot) && (slot < 9 + 7 - offset || slot > 9 + 13 - offset) ==> stack[0][slot] == old(stack[0][slot]);
    SeqTail(stack, 1) == old(SeqTail(stack, 1));
{
  ghost var a := r11d;
  ghost var b := stack[0][9 + offset + 0];
  ghost var c := stack[0][9 + offset + 1];
  ghost var d := stack[0][9 + offset + 2];
  ghost var e := stack[0][9 + offset + 3];
  ghost var f := stack[0][9 + offset + 4];
  ghost var g := stack[0][9 + offset + 5];
  ghost var h := stack[0][9 + offset + 6];

  eax := r11d;
  StoreStack(9 + 7 - offset, eax);     // b_final := a
  LoadStack(r8d, 9 + offset);          // b
  StoreStack(9 + 8 - offset, r8d);     // c_final := b
  LoadStack(ecx, 9 + offset + 1);   // c
  StoreStack(9 + 9 - offset, ecx);     // d_final := c
  edx    := r8d;

  lemma_BitwiseCommutative(r8d, eax);
  r8d &= eax; // b & a
  edx &= ecx; // b & c
  lemma_BitwiseCommutative(ecx, eax);
  ecx &= eax; // c & a
  r8d ^= ecx;
  r8d ^= edx; // my_maj
  forall :: r8d == Maj(a, b, c)
  {
    reveal_Maj();
  }
  //    After above block, live: 
  //    eax == a
  //    r8d == my_maj

  // Calculate bsig0
  ecx := eax;
  edx := eax;
  Ror32(eax, 2);
  Ror32(ecx, 13);
  eax ^= ecx;
  Ror32(edx, 22);
  eax ^= edx;   // == bsig0
  forall :: eax == BSIG0(a)
  {
    reveal_BSIG0();
  }
  eax += r8d; // == T2

  // Calculate my_ch
  LoadStack(r8d, 9 + offset + 3);  // e
  StoreStack(9 + 11 - offset, r8d);    // f_final := e
  edx    := r8d;
  Not32(edx);
  LoadStack(ecx, 9 + offset + 5);  // g
  StoreStack(9 + 13 - offset, ecx);    // h_final := g
  edx    &= ecx; // !e & g
  LoadStack(ecx, 9 + offset + 4);  // f
  StoreStack(9 + 12 - offset, ecx);    // g_final := f
  lemma_BitwiseCommutative(ecx, r8d);
  ecx    &= r8d; // f & e  // Need commutativity
  lemma_BitwiseCommutative(ecx, edx);
  ecx    ^= edx; // my_ch  // Need commutativity
  forall :: ecx == Ch(e, f, g)
  {
    reveal_Ch();
  }
  //    After above block, live: 
  //      eax == T2
  //      r8d == e
  //      ecx == my_ch

  // Calculate bsig1
  edx := r8d;
  r10d := r8d;
  Ror32(edx, 6);
  Ror32(r10d, 11);
  edx ^= r10d;
  Ror32(r8d, 25);
  edx ^= r8d;   // == bsig1
  forall :: edx == BSIG1(e)
  {
    reveal_BSIG1();
  }
  //    After above block, live: 
  //      eax == T2
  //      ecx == my_ch
  //      edx == bsig1

  // Calculate T1
  LoadStack(r8d, 9 + offset + 6);      // h
  r8d += edx; // Frees edx
  r8d += ecx; // Frees ecx
  Add32Wrap(r8d, K);
  Load(ecx, r9, W_offset, W_taint, W_id);
  r8d += ecx; // T1
  lemma_BitwiseAdd32Commutative(eax, r8d);
  eax += r8d; // T2 + T1 == a_final
  r11d := eax;    // a_final := eax
  LoadStack(eax, 9 + offset + 2);    // d
  eax += r8d; // d + T1
  StoreStack(9 + 10 - offset, eax);   // e_final := eax

  // OBSERVE: Triggers
  assert TBlk(SeqLength(z.H)-1) && TBlk(SeqLength(z.H)) && TStep(currentStep) && TStep(currentStep + 1);

  ghost var a_final := r11d;
  ghost var b_final := stack[0][9 + 7 - offset];
  ghost var c_final := stack[0][9 + 8 - offset];
  ghost var d_final := stack[0][9 + 9 - offset];
  ghost var e_final := stack[0][9 + 10 - offset];
  ghost var f_final := stack[0][9 + 11 - offset];
  ghost var g_final := stack[0][9 + 12 - offset];
  ghost var h_final := stack[0][9 + 13 - offset];

  final_atoh := atoh_c(a_final, b_final, c_final, d_final, e_final, f_final, g_final, h_final);
  final_z := SHA256Trace_c(z.M, z.H, z.W, SeqDrop(z.atoh, SeqLength(z.H)-1) + SeqBuild(SeqAppendElt(z.atoh[SeqLength(z.H)-1], final_atoh)));
  ghost var final_s := currentState.(atoh := final_atoh); 
  lemma_SHA256TransitionOKAfterSettingAtoH(z, currentState, final_z, final_s, currentStep);
}

procedure {:refined} ComputeTwoSteps_SHA256_core(
  inline K1:uint32,
  inline K2:uint32,
  inline W_offset1:uint32,
  inline W_offset2:uint32,
  inline W_taint:taint,
  ghost W_id:heaplet_id,
  ghost atoh:atoh_Type,
  ghost z:SHA256Trace,
  ghost currentStep:uint32, 
  ghost currentState:SHA256_state
) returns (
  ghost final_atoh:atoh_Type,
  ghost final_z:SHA256Trace
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
  requires/ensures
    // Vale requirements
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 256);
    SeqLength(currentState.W) == 64;
    // SHA requirements
    SeqLength(z.H) > 0;
    currentStep <= 62;
    K1 == K_SHA256(currentStep);
    K2 == K_SHA256(currentStep+1);
  requires
    atoh == atoh_c(r11d,
                   stack[0][9 + 0],
                   stack[0][9 + 1],
                   stack[0][9 + 2],
                   stack[0][9 + 3],
                   stack[0][9 + 4],
                   stack[0][9 + 5],
                   stack[0][9 + 6]);
    currentState.atoh == atoh;
    forall j :: 0 <= j < 64 ==> currentState.W[j] == mem[W_id].words[r9 + 4 * j].v;
    IsSHA256ReadyForStep(z, currentState, currentStep);
    W_offset1 == 4 * currentStep;
    W_offset2 == 4 * (currentStep + 1);
  reads
    mem; r9;
  modifies
    efl; stack; eax; r8d; ecx; edx; r10d; r11d;
  ensures
    // SHA postconditions
    final_atoh == atoh_c(r11d,
                         stack[0][9 + 0],
                         stack[0][9 + 1],
                         stack[0][9 + 2],
                         stack[0][9 + 3],
                         stack[0][9 + 4],
                         stack[0][9 + 5],
                         stack[0][9 + 6]);
    IsSHA256ReadyForStep(final_z, currentState.(atoh := final_atoh), currentStep+2);
    SeqLength(final_z.H) == SeqLength(z.H);
    final_z.M == z.M;
    // Framing
    forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
    forall slot :: HasStackSlot(stack, slot) && slot > 9 + 13 ==> stack[0][slot] == old(stack[0][slot]);
    SeqTail(stack, 1) == old(SeqTail(stack, 1));
{
    ghost var mid_atoh:atoh_Type;
    ghost var mid_z:SHA256Trace;
    mid_atoh, mid_z := ComputeOneStep_SHA256_core(0, K1, W_offset1, W_taint, W_id, atoh, z, currentStep, currentState);
    ghost var mid_state := currentState.(atoh := mid_atoh);
    ghost var mid_step := currentStep + 1;
    final_atoh, final_z := ComputeOneStep_SHA256_core(7, K2, W_offset2, W_taint, W_id, mid_atoh, mid_z, mid_step, mid_state);
    assert final_atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]);
    assert IsSHA256ReadyForStep(final_z, currentState.(atoh := final_atoh), currentStep + 2);
}

procedure {:refined} {:recursive} SHA256_inner_loopUnrolled_recursive(
    ghost W_id:heaplet_id,
    inline W_taint:taint,
    ghost current_z:SHA256Trace,
    ghost current_state:SHA256_state,
    inline n:uint8
    ) returns (
    ghost new_z:SHA256Trace,
    ghost new_state:SHA256_state
    )
    requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
    ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
    requires/ensures
        SeqLength(stack) > 0;
        HasStackSlots(stack, 9 + 19);
    requires
        0 <= n <= 32;
        ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 256);
        SeqLength(current_state.W) == 64;
        SeqLength(current_z.H) > 0;
        current_state.atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]);
        IsSHA256ReadyForStep(current_z, current_state, 0);
        forall j :: 0 <= j < 64 ==> current_state.W[j] == mem[W_id].words[r9 + 4*j].v;
    ensures
        new_state == current_state.(atoh := new_state.atoh);
        new_state.atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]);
        SeqLength(new_z.H) == SeqLength(current_z.H);
        new_z.M == current_z.M;
        forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
        forall slot :: HasStackSlot(stack, slot) && slot > 9 + 13 ==> stack[0][slot] == old(stack)[0][slot];
        SeqTail(stack, 1) == SeqTail(old(stack), 1);
        IsSHA256ReadyForStep(new_z, new_state, 2*n);
    reads
        r9; mem;
    modifies
        efl; stack; eax; r8d; ecx; edx; r10d; r11d;
{
    inline if (0 < n <= 32) { // The <= 32 part is because the code-generation lemma doesn't get to see the requirements of this procedure
        ghost var mid_z:SHA256Trace;
        ghost var mid_state:SHA256_state;
        mid_z, mid_state := SHA256_inner_loopUnrolled_recursive(W_id, W_taint, current_z, current_state, n-1);
        ghost var new_atoh:atoh_Type;
        new_atoh, new_z := ComputeTwoSteps_SHA256_core(K_SHA256(2*(n-1)), K_SHA256(2*(n-1)+1), 4*(2*(n-1)), 4*(2*(n-1)+1), W_taint, W_id, mid_state.atoh, mid_z, 2*(n-1), mid_state);
        new_state := mid_state.(atoh := new_atoh);
    } else {
        new_state := current_state;
        new_z := current_z;
    }
}

procedure {:refined}{:bridge} SHA256_inner_loopUnrolled(
    ghost W_id:heaplet_id,
    inline W_taint:taint,
    ghost current_z:SHA256Trace,
    ghost current_state:SHA256_state
    )
//    returns (
//    ghost new_z:SHA256Trace,
//    ghost new_state:SHA256_state
//    )
    requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
    ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R10); reg32(this, X86R11);
    requires/ensures
        SeqLength(stack) > 0;
        HasStackSlots(stack, 9 + 19);
    requires
        ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 256);
        SeqLength(current_state.W) == 64;
        SeqLength(current_z.H) > 0;
        current_state.atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]);
        IsSHA256ReadyForStep(current_z, current_state, 0);
        forall j :: 0 <= j < 64 ==> current_state.W[j] == mem[W_id].words[r9 + 4*j].v;
    ensures
      exists new_z:SHA256Trace, new_state:SHA256_state ::
        new_state == current_state.(atoh := new_state.atoh) &&
        new_state.atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]) &&
        SeqLength(new_z.H) == SeqLength(current_z.H) &&
        new_z.M == current_z.M &&
        (forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot)) &&
        (forall slot :: HasStackSlot(stack, slot) && slot > 9 + 13 ==> stack[0][slot] == old(stack)[0][slot]) &&
        SeqTail(stack, 1) == SeqTail(old(stack), 1) &&
        IsSHA256ReadyForStep(new_z, new_state, 64);
    reads
        r9; mem;
    modifies
        efl; stack; eax; r8d; ecx; edx; r10d; r11d;
{
    ghost var new_z;
    ghost var new_state;
    new_z, new_state := SHA256_inner_loopUnrolled_recursive(W_id, W_taint, current_z, current_state, 32);
}

procedure {:refined}{:bridge} MoveFromHeapToStack(ghost H_id:heaplet_id, inline taint:taint)
  requires{:refined false} reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86R8); reg32(this, X86R11);
  requires/ensures
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddrs(mem, H_id, rcx, 32, taint, 32);
  reads 
    mem; rcx;
  modifies
    stack; r8d; r11d;
  ensures
    r11d         == mem[H_id].words[rcx + 0].v;
    stack[0][9 + 0] == mem[H_id].words[rcx + 4].v;
    stack[0][9 + 1] == mem[H_id].words[rcx + 8].v;
    stack[0][9 + 2] == mem[H_id].words[rcx + 12].v;
    stack[0][9 + 3] == mem[H_id].words[rcx + 16].v;
    stack[0][9 + 4] == mem[H_id].words[rcx + 20].v;
    stack[0][9 + 5] == mem[H_id].words[rcx + 24].v;
    stack[0][9 + 6] == mem[H_id].words[rcx + 28].v;

    // Framing
    forall slot :: HasStackSlot(stack, slot) <==> old(HasStackSlot(stack, slot));
    forall slot :: HasStackSlot(stack, slot) && slot > 9 + 7 
               ==> stack[0][slot] == old(stack[0][slot]);
    SeqTail(stack, 1) == old(SeqTail(stack, 1));
{
    Load(r11d, rcx, 0, taint, H_id);  // Temp value 'a' lives in r11d; the rest on the stack
    Load(r8d, rcx, 4, taint, H_id);
    StoreStack(9 + 0, r8d);
    Load(r8d, rcx, 8, taint, H_id);
    StoreStack(9 + 1, r8d);
    Load(r8d, rcx, 12, taint, H_id);
    StoreStack(9 + 2, r8d);
    Load(r8d, rcx, 16, taint, H_id);
    StoreStack(9 + 3, r8d);
    Load(r8d, rcx, 20, taint, H_id);
    StoreStack(9 + 4, r8d);
    Load(r8d, rcx, 24, taint, H_id);
    StoreStack(9 + 5, r8d);
    Load(r8d, rcx, 28, taint, H_id);
    StoreStack(9 + 6, r8d);
}

// Calling convention:
// rcx = heap destination
procedure {:refined}{:bridge} {:timeLimitMultiplier 2} MoveFromStackToHeap(ghost H_id:heaplet_id, inline taint:taint)
  requires{:refined false} reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86R8); reg32(this, X86R11);
  requires/ensures
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddrs(mem, H_id, rcx, 32, taint, 32);
  reads 
    stack; rcx;
  modifies
    mem; r8d; r11d; efl;
  ensures
    mem[H_id].words[rcx + 0].v  == old(BitwiseAdd32(mem[H_id].words[rcx + 0].v,  r11d        ));
    mem[H_id].words[rcx + 4].v  == old(BitwiseAdd32(mem[H_id].words[rcx + 4].v,  stack[0][9 + 0]));
    mem[H_id].words[rcx + 8].v  == old(BitwiseAdd32(mem[H_id].words[rcx + 8].v,  stack[0][9 + 1]));
    mem[H_id].words[rcx + 12].v == old(BitwiseAdd32(mem[H_id].words[rcx + 12].v, stack[0][9 + 2]));
    mem[H_id].words[rcx + 16].v == old(BitwiseAdd32(mem[H_id].words[rcx + 16].v, stack[0][9 + 3]));
    mem[H_id].words[rcx + 20].v == old(BitwiseAdd32(mem[H_id].words[rcx + 20].v, stack[0][9 + 4]));
    mem[H_id].words[rcx + 24].v == old(BitwiseAdd32(mem[H_id].words[rcx + 24].v, stack[0][9 + 5]));
    mem[H_id].words[rcx + 28].v == old(BitwiseAdd32(mem[H_id].words[rcx + 28].v, stack[0][9 + 6]));

    // Framing
    mem == old(mem)[H_id := mem[H_id]];
    forall addr :: mem[H_id].words?[addr] <==> old(mem)[H_id].words?[addr];
    forall a :: (a < rcx || a > rcx + 28) && old(mem)[H_id].words?[a]
             ==> mem[H_id].words?[a] && mem[H_id].words[a] == old(mem)[H_id].words[a];
{
    // Here's a spot where we're using a Load that would otherwise be a direct Add32 on a heap operand 
    // (see previous version in git history for an example).
    // Hopefully it doesn't hurt our perf too much.
    Load(r8d, rcx, 0, taint, H_id);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 0, taint, H_id);   // H[0] += a

    Load(r8d, rcx, 4, taint, H_id);
    LoadStack(r11d, 9 + 0);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 4, taint, H_id);   // H[1] += b

    Load(r8d, rcx, 8, taint, H_id);
    LoadStack(r11d, 9 + 1);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 8, taint, H_id);   // H[2] += c

    Load(r8d, rcx, 12, taint, H_id);
    LoadStack(r11d, 9 + 2);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 12, taint, H_id);  // H[3] += c

    Load(r8d, rcx, 16, taint, H_id);
    LoadStack(r11d, 9 + 3);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 16, taint, H_id);  // H[4] += c

    Load(r8d, rcx, 20, taint, H_id);
    LoadStack(r11d, 9 + 4);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 20, taint, H_id);  // H[5] += c

    Load(r8d, rcx, 24, taint, H_id);
    LoadStack(r11d, 9 + 5);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 24, taint, H_id);  // H[6] += c

    Load(r8d, rcx, 28, taint, H_id);
    LoadStack(r11d, 9 + 6);
    Add32Wrap(r8d, r11d); 
    Store(rcx, r8d, 28, taint, H_id);  // H[7] += c
}

procedure {:refined}{:bridge} scrub_stack()
requires/ensures
    HasStackSlots(stack, 9 + 19);
modifies stack;
ensures 
    forall slot :: 9 + 0 <= slot < 9 + 19 ==> stack[0][slot] == 0;
    forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
    forall slot :: !(9 + 0 <= slot < 9 + 19) && stack[0]?[slot] ==> old(stack)[0]?[slot] && stack[0][slot] == old(stack)[0][slot];
    SeqTail(stack, 1) == old(SeqTail(stack, 1));
{
    StoreStack(9 + 0, 0);
    StoreStack(9 + 1, 0);
    StoreStack(9 + 2, 0);
    StoreStack(9 + 3, 0);
    StoreStack(9 + 4, 0);
    StoreStack(9 + 5, 0);
    StoreStack(9 + 6, 0);
    StoreStack(9 + 7, 0);
    StoreStack(9 + 8, 0);
    StoreStack(9 + 9, 0);
    StoreStack(9 + 10, 0);
    StoreStack(9 + 11, 0);
    StoreStack(9 + 12, 0);
    StoreStack(9 + 13, 0);
    StoreStack(9 + 14, 0);
    StoreStack(9 + 15, 0);
    StoreStack(9 + 16, 0);
    StoreStack(9 + 17, 0);
    StoreStack(9 + 18, 0);
}

// Entry-point for the Dafny-level SHA code
// Note that we require 16 stack slots at present to provide scratch space for SHA calculations
// 
// Calling convention:
// Registers initially contain: (Windows/Linux)
// rcx/rdi = H
// rdx/rsi = W
// r8 /rdx = 0/scratch
// r9 /rcx = 0/scratch
// stack (rsp+(10*4))/r8 = 0/scratch
procedure SHA256_Compute64StepsH(
    ghost H_id:heaplet_id,      // Hash state
    ghost W_id:heaplet_id,      // Expanded message words
    inline H_taint:taint,
    inline W_taint:taint,
    inline win:bool,
    ghost z:SHA256Trace,
    ghost current_state:SHA256_state
  ) returns (
     ghost z':SHA256Trace,
     ghost current_state':SHA256_state
  )
  requires
    // Vale requirements
    let H := if win then rcx else rdi;
    let W := if win then rdx else rsi;
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddrs(mem, H_id, H, 32, H_taint, 32);
    ValidSrcAddrs(mem, W_id, W, 32, W_taint, 256);
  requires
    let H := if win then rcx else rdi;
    let W := if win then rdx else rsi;
    H_id != W_id;

    // SHA requirements

    // current_state.atoh == atoh_c(H[0], H[1], H[2], H[3], H[4], H[5], H[6], H[7]);
    current_state.atoh == atoh_c(mem[H_id].words[H +  0].v,
                                 mem[H_id].words[H +  4].v,
                                 mem[H_id].words[H +  8].v,
                                 mem[H_id].words[H + 12].v,
                                 mem[H_id].words[H + 16].v,
                                 mem[H_id].words[H + 20].v,
                                 mem[H_id].words[H + 24].v,
                                 mem[H_id].words[H + 28].v);
    IsSHA256ReadyForStep(z, current_state, 0); 
    forall i :: 0 <= i < SeqLength(current_state.W)
            ==> mem[W_id].words[W + 4*i].v == current_state.W[i];
  reads
    rsi; rdi;
  modifies 
    stack; mem; eax; r8d; ecx; edx; r10d; r11d; r9d; efl;
    rcx; rdx; r8; r9;
  ensures
    let H := if win then old(rcx) else old(rdi);
    let H32 := if win then old(rcx+32) else old(rdi+32);
    let W := if win then old(rdx) else old(rsi);
    
    // Vale framing
    HasStackSlots(stack, 9 + 19);
    ValidSrcAddrs(mem, H_id, H, 32, H_taint, 32);
    ValidSrcAddrs(mem, W_id, W, 32, W_taint, 256);

    mem == old(mem)[H_id := mem[H_id]]; // Only H's are modified
    forall addr :: mem[H_id].words?[addr] <==> old(mem)[H_id].words?[addr];
    forall addr :: (addr < H || addr >= H32) && mem[H_id].words?[addr]
                ==> mem[H_id].words[addr] == old(mem[H_id].words[addr]);

    forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
    forall slot :: HasStackSlot(stack, slot) && HasStackSlot(old(stack), slot) && slot >= 9 + 19
                ==> stack[0][slot] == old(stack[0][slot]);
    forall slot :: 9 + 0 <= slot < 9 + 19 ==> stack[0][slot] == 0;
    SeqTail(stack, 1) == old(SeqTail(stack, 1));

    // Calling convention
//    r8d == old(r8d);
//    r9d == old(r9d);
//    r10d == old(r10d);
//    r11d == old(r11d);

    // SHA
    IsSHA256ReadyForStep(z', current_state', 64);
    current_state'.W == current_state.W;
    current_state'.H == current_state.H;
    mem[H_id].words[H +  0].v == BitwiseAdd32(current_state'.atoh.a, old(mem[H_id].words[H +  0].v));
    mem[H_id].words[H +  4].v == BitwiseAdd32(current_state'.atoh.b, old(mem[H_id].words[H +  4].v));
    mem[H_id].words[H +  8].v == BitwiseAdd32(current_state'.atoh.c, old(mem[H_id].words[H +  8].v));
    mem[H_id].words[H + 12].v == BitwiseAdd32(current_state'.atoh.d, old(mem[H_id].words[H + 12].v));
    mem[H_id].words[H + 16].v == BitwiseAdd32(current_state'.atoh.e, old(mem[H_id].words[H + 16].v));
    mem[H_id].words[H + 20].v == BitwiseAdd32(current_state'.atoh.f, old(mem[H_id].words[H + 20].v));
    mem[H_id].words[H + 24].v == BitwiseAdd32(current_state'.atoh.g, old(mem[H_id].words[H + 24].v));
    mem[H_id].words[H + 28].v == BitwiseAdd32(current_state'.atoh.h, old(mem[H_id].words[H + 28].v));
    SeqLength(z'.H) == SeqLength(z.H);
    z'.M == z.M;
{
    inline if (win)
    {        
        Mov64(r9, rdx);             // Load W into r9, where inner loop expects it
        StoreStack64(9 + 14, rcx);  // Save a copy of H for after the inner loop
    }
    else
    {        
        Mov64(r9, rsi);             // Load W into r9, where inner loop expects it
        StoreStack64(9 + 14, rdi);  // Save a copy of H for after the inner loop
        Mov64(rcx, rdi);            // Load H into rcx, where StoreStack64 expects it
    }
    
    // HACK: clear upper 32 bits of registers to satisfy precondition:
    Mov32(r8d, 0);
    Mov32(r11d, 0);

    MoveFromHeapToStack(H_id, H_taint); 

    // HACK: clear upper 32 bits of registers to satisfy precondition:
    Mov32(eax, 0);
    Mov32(ecx, 0);
    Mov32(edx, 0);
    Mov32(r10d, 0);

//    z', current_state' := SHA256_inner_loopUnrolled(W_id, W_taint, z, current_state);
ghost var stack0 := stack;
ghost var current_z := z;
    SHA256_inner_loopUnrolled(W_id, W_taint, z, current_state);
exists new_z:SHA256Trace, new_state:SHA256_state ::
        new_state == current_state.(atoh := new_state.atoh) &&
        new_state.atoh == atoh_c(r11d, stack[0][9 + 0], stack[0][9 + 1], stack[0][9 + 2], stack[0][9 + 3], stack[0][9 + 4], stack[0][9 + 5], stack[0][9 + 6]) &&
        SeqLength(new_z.H) == SeqLength(current_z.H) &&
        new_z.M == current_z.M &&
        (forall slot :: HasStackSlot(stack0, slot) <==> HasStackSlot(stack, slot)) &&
        (forall slot :: HasStackSlot(stack, slot) && slot > 9 + 13 ==> stack[0][slot] == stack0[0][slot]) &&
        SeqTail(stack, 1) == SeqTail(stack0, 1) &&
        IsSHA256ReadyForStep(new_z, new_state, 64);
z' := new_z;
current_state' := new_state;

    lemma_BitwiseAdd32CommutativeAlways();

    // Now compute the BitwiseAdds and store the results back in H
    LoadStack64(rcx, 9 + 14);      // Load H_ptr into rcx so we can retrieve the original values

    MoveFromStackToHeap(H_id, H_taint); 

    // Restore registers
//    LoadStack(r11d, 9 + 15);
//    LoadStack(r8d, 9 + 16);
//    LoadStack(r9d, 9 + 17);
//    LoadStack(r10d, 9 + 18);

    scrub_stack();
}

procedure {:refined} SHA256_ComputeInitialWs_bitwise(
  ghost W_id:heaplet_id,     // Expanded message words
  inline taint:taint,
  inline t:uint8      // Using uint8 here (and addition below instead of subtraction) to avoid under/over-flow complaints from Dafny
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  requires/ensures
    // Vale requirements
    ValidSrcAddr(mem, W_id, r9 + 4*(t + 14), 32, taint);
    ValidSrcAddr(mem, W_id, r9 + 4*(t +  9), 32, taint);
    ValidSrcAddr(mem, W_id, r9 + 4*(t +  1), 32, taint);
    ValidSrcAddr(mem, W_id, r9 + 4*(t),      32, taint);
  requires
    ValidDstAddr(mem, W_id, r9 + 4*(t + 16), 32);
    0 <= t < 48;
  ensures
    ValidSrcAddr(mem, W_id, r9 + 4*(t + 16), 32, taint);
  reads 
    r9;
  modifies
    efl; mem; eax; r8d; ecx; edx;
  ensures
    // Vale framing
    mem == old(mem)[W_id := old(mem)[W_id].(words := old(mem)[W_id].words[r9 + 4*(t + 16) := mem[W_id].words[r9 + 4*(t + 16)]])];

    // SHA
    let W := mem[W_id].words in
      W[r9 + 4*(t + 16)].v == 
        BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[r9 + 4*(t + 14)].v), 
                                               W[r9 + 4*(t + 9)].v), 
                                  SSIG0(W[r9 + 4*(t + 1)].v)), 
                     W[r9 + 4*t].v);

{
    reveal_SSIG0();
    reveal_SSIG1();
    Load(eax, r9, 4*(t+14), taint, W_id);
    r8d := eax;
    ecx := eax;
    Ror32(r8d, 17);
    Ror32(ecx, 19);
    r8d ^= ecx;
    Shr32(eax, 10);
    r8d ^= eax; // r8d == SSIG1(W[t-2])

    Load(edx, r9, 4*(t+9), taint, W_id);
    lemma_BitwiseAdd32Commutative(edx, r8d);
    edx += r8d; // edx == W[t-7] + SSIG1(W[t-2])

    Load(eax, r9, 4*(t+1), taint, W_id);
    r8d := eax;
    ecx := eax;
    Ror32(r8d, 7);
    Ror32(ecx, 18);
    r8d ^= ecx;
    Shr32(eax, 3);
    r8d ^= eax; // r8d == SSIG0(W[t-15])
    edx += r8d;

    Load(eax, r9, 4*t, taint, W_id);
    edx += eax; // edx == W[t-7] + SSIG1(W[t-2]) + SSIG0(W[t-15]) + W[t-16]

    Store(r9, edx, 4*(t+16), taint, W_id);
}

procedure {:refined} {:recursive} SHA256_init_Ws_loopUnrolled_recursive(
  ghost W_id:heaplet_id,     // Expanded message words
  inline W_taint:taint,
  inline n:uint8
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  requires/ensures
    ValidDstAddrs(mem, W_id, r9, 32, 256);
  requires
    r9 % 4 == 0;
    ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 64);
    0 <= n <= 48;
  ensures
    ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 4*(n+16));
  reads
    r10; r9;
  modifies
    efl; mem; eax; r8d; ecx; edx;
  ensures
    // SHA
    forall t:uint32 {TStep(t)} :: 
           0 <= t < n && TStep(t)
       ==> (let W := mem[W_id].words in
               W[r9 + 4*(t + 16)].v ==
                 BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[r9 + 4*(t + 14)].v), 
                                                        W[r9 + 4*(t + 9)].v), 
                                           SSIG0(W[r9 + 4*(t + 1)].v)),
                              W[r9 + 4*t].v));

    // Framing
    mem == old(mem)[W_id := mem[W_id]];   // Only W_id's heaplet changes
    forall a :: (a < r9 + 64 || a >= r9 + 256) && old(mem)[W_id].words?[a] 
             ==> mem[W_id].words?[a] && mem[W_id].words[a] == old(mem)[W_id].words[a];
{
    inline if (n > 0) {
        SHA256_init_Ws_loopUnrolled_recursive(W_id, W_taint, n-1);
        SHA256_ComputeInitialWs_bitwise(W_id, W_taint, n-1);
    }
}

procedure {:refined} SHA256_init_Ws_loopUnrolled(
  ghost W_id:heaplet_id,     // Expanded message words
  inline W_taint:taint
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  requires
    r9 % 4 == 0;
    ValidDstAddrs(mem, W_id, r9, 32, 256);
    ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 64);
  ensures
    ValidSrcAddrs(mem, W_id, r9, 32, W_taint, 256); 
  reads
    r10; r9;
  modifies
    efl; mem; eax; r8d; ecx; edx;
  ensures
    // SHA
    forall t:uint32 {TStep(t)} :: 
           0 <= t < 48 && TStep(t)
       ==> (let W := mem[W_id].words in
               W[r9 + 4*(t + 16)].v ==
                 BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[r9 + 4*(t + 14)].v), 
                                                        W[r9 + 4*(t + 9)].v), 
                                           SSIG0(W[r9 + 4*(t + 1)].v)),
                              W[r9 + 4*t].v));

    // Framing
    mem == old(mem)[W_id := mem[W_id]];   // Only W_id's heaplet changes
    forall a :: (a < r9 + 64 || a >= r9 + 256) && old(mem)[W_id].words?[a] 
             ==> mem[W_id].words?[a] && mem[W_id].words[a] == old(mem)[W_id].words[a];
{
    SHA256_init_Ws_loopUnrolled_recursive(W_id, W_taint, 48);
}

procedure {:refined} {:timeLimitMultiplier 6} SHA256_ComputeInitialWs_memcpy(
  ghost M_id:heaplet_id,     // Message words
  ghost W_id:heaplet_id,     // Expanded message words
  inline M_taint:taint
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  requires
    // Vale requirements
    ValidSrcAddrs(mem, M_id, r10, 32, M_taint, 64);
    ValidDstAddrs(mem, W_id, r9, 32, 64);
  requires 
    M_id != W_id;
  reads
    r10; r9;
  modifies
    mem; eax; r8d; ecx; edx; r11d;
  ensures
    ValidSrcAddrs(mem, M_id, r10, 32, M_taint, 64);
    ValidSrcAddrs(mem, W_id, r9, 32, M_taint, 64);

    // SHA
    forall i :: 0 <= i < 64 && i % 4 == 0 ==> mem[W_id].words[r9 + i].v == bswap32(old(mem[M_id].words[r10 + i].v));
    forall i :: 0 <= i < 64 && i % 4 == 0 ==> mem[W_id].words[r9 + i].t == old(mem[M_id].words[r10 + i].t);

    // Framing
    mem == old(mem)[W_id := mem[W_id]];   // Only W_id's heaplet changes
    forall a :: (a < r9 || a >= r9 + 64) && old(mem)[W_id].words?[a] 
             ==> mem[W_id].words?[a] && mem[W_id].words[a] == old(mem)[W_id].words[a];
{
    // Move M into W, 5 words at a time (maybe using different registers allows more/better pipelining?)
    LoadBSwap(eax, r10,  0, M_taint, M_id);
    LoadBSwap(r8d, r10,  4, M_taint, M_id);
    LoadBSwap(ecx, r10,  8, M_taint, M_id);
    LoadBSwap(edx, r10, 12, M_taint, M_id);
    LoadBSwap(r11d, r10, 16, M_taint, M_id);

    Store(r9, eax,  0, M_taint, W_id);
    Store(r9, r8d,  4, M_taint, W_id);
    Store(r9, ecx,  8, M_taint, W_id);
    Store(r9, edx, 12, M_taint, W_id);
    Store(r9, r11d, 16, M_taint, W_id);

    LoadBSwap(eax, r10, 20, M_taint, M_id);
    LoadBSwap(r8d, r10, 24, M_taint, M_id);
    LoadBSwap(ecx, r10, 28, M_taint, M_id);
    LoadBSwap(edx, r10, 32, M_taint, M_id);
    LoadBSwap(r11d, r10, 36, M_taint, M_id);

    Store(r9, eax, 20, M_taint, W_id);
    Store(r9, r8d, 24, M_taint, W_id);
    Store(r9, ecx, 28, M_taint, W_id);
    Store(r9, edx, 32, M_taint, W_id);
    Store(r9, r11d, 36, M_taint, W_id);

    LoadBSwap(eax, r10, 40, M_taint, M_id);
    LoadBSwap(r8d, r10, 44, M_taint, M_id);
    LoadBSwap(ecx, r10, 48, M_taint, M_id);
    LoadBSwap(edx, r10, 52, M_taint, M_id);
    LoadBSwap(r11d, r10, 56, M_taint, M_id);

    Store(r9, eax, 40, M_taint, W_id);
    Store(r9, r8d, 44, M_taint, W_id);
    Store(r9, ecx, 48, M_taint, W_id);
    Store(r9, edx, 52, M_taint, W_id);
    Store(r9, r11d, 56, M_taint, W_id);

    LoadBSwap(eax, r10, 60, M_taint, M_id);
    Store(r9, eax, 60, M_taint, W_id);
}

procedure {:refined}{:bridge} SHA256_ComputeInitialWs_internal(
  ghost M_id:heaplet_id,     // Message words
  ghost W_id:heaplet_id,     // Expanded message words
  inline M_taint:taint
)
  requires{:refined false} reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  ensures{:refined false}  reg32(this, X86Eax); reg32(this, X86Ecx); reg32(this, X86Edx); reg32(this, X86R8); reg32(this, X86R11);
  requires
    // Vale requirements
    r9 % 4 == 0;
    ValidSrcAddrs(mem, M_id, r10, 32, M_taint, 64);
    ValidDstAddrs(mem, W_id, r9, 32, 256); 
  requires 
    M_id != W_id;
  reads
    r10; r9;
  modifies
    efl; mem; eax; r8d; ecx; edx; r11d;
  ensures
    // Vale requirements
    ValidSrcAddrs(mem, M_id, r10, 32, M_taint, 64);
    ValidSrcAddrs(mem, W_id, r9, 32, M_taint, 256); 
    // SHA
    forall i :: 0 <= i < 64 && i % 4 == 0 ==> mem[W_id].words[r9 + i].v == bswap32(old(mem[M_id].words[r10 + i].v));
    forall i :: 0 <= i < 64 && i % 4 == 0 ==> mem[W_id].words[r9 + i].t == old(mem[M_id].words[r10 + i].t);
    forall t:uint32 {TStep(t)} :: 
           0 <= t < 48 && TStep(t)
       ==> (let W := mem[W_id].words in
               W[r9 + 4*(t + 16)].v == 
                 BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[r9 + 4*(t + 14)].v), 
                                                        W[r9 + 4*(t + 9)].v), 
                                           SSIG0(W[r9 + 4*(t + 1)].v)), 
                              W[r9 + 4*t].v));

    // Framing
    mem == old(mem)[W_id := mem[W_id]];   // Only W_id's heaplet changes
    forall a :: (a < r9 || a >= r9 + 256) && old(mem)[W_id].words?[a] 
             ==> mem[W_id].words?[a] && mem[W_id].words[a] == old(mem)[W_id].words[a];
{
    SHA256_ComputeInitialWs_memcpy(M_id, W_id, M_taint);
    SHA256_init_Ws_loopUnrolled(W_id, M_taint);
}

#verbatim
function GetBytesToWord(mem:Heaplets, bytes_id:heaplet_id, addr:int) : int
    // We don't care about taint for this function's purposes, so call it a dst
    requires ValidDstAddr(mem, bytes_id, addr,   8);
    requires ValidDstAddr(mem, bytes_id, addr+1, 8);
    requires ValidDstAddr(mem, bytes_id, addr+2, 8);
    requires ValidDstAddr(mem, bytes_id, addr+3, 8);
{
    BytesToWord(mem[bytes_id].bytes[addr].v,
                mem[bytes_id].bytes[addr+1].v,
                mem[bytes_id].bytes[addr+2].v,
                mem[bytes_id].bytes[addr+3].v)
}

predicate T<T>(x:T) { true }

predicate IsWordHeaplet(h:Heaplet) { h.WordHeaplet? }

function CastBytesToWordsSrc(addr:int, src:Heaplet, dst:Heaplet, num_words:nat) : Heaplet
    requires src.ByteHeaplet?;
    requires dst.WordHeaplet?;
    requires forall a :: addr <= a < addr + 4*num_words && (a - addr) % 4 == 0
                      ==> a + 0 in src.bytes
                       && a + 1 in src.bytes
                       && a + 2 in src.bytes
                       && a + 3 in src.bytes;
{
    CastBytesToWords(addr, src, dst, num_words).0
}

function CastBytesToWordsDst(addr:int, src:Heaplet, dst:Heaplet, num_words:nat) : Heaplet
    requires src.ByteHeaplet?;
    requires dst.WordHeaplet?;
    requires forall a :: addr <= a < addr + 4*num_words && (a - addr) % 4 == 0
                      ==> a + 0 in src.bytes
                       && a + 1 in src.bytes
                       && a + 2 in src.bytes
                       && a + 3 in src.bytes;
{
    CastBytesToWords(addr, src, dst, num_words).1
}

function EmptyWordHeaplet() : Heaplet { WordHeaplet(map[]) }

// Code generated via Vale.  From the program's perspective, the cast is a no op
function method{:opaque} va_code_CastBytesToWords(num_bytes:uint32, taint:taint):va_code
{
  Block(CNil())
}

// Signature generated via Vale.  Body filled in by hand.
lemma va_refined_CastBytesToWords(va_b0:va_codes, va_s0:va_state, va_sN:va_state, num_bytes:uint32, taint:taint)
  returns (va_bM:va_codes, va_sM:va_state)
  requires va_require(va_b0, va_code_CastBytesToWords(num_bytes, taint), va_s0, va_sN)
  ensures  va_ensure(va_b0, va_bM, va_s0, va_sM, va_sN)
  ensures  va_spec_CastBytesToWords(num_bytes, taint, va_get_ok(va_s0), va_get_ok(va_sM), va_get_reg64(X86R10, va_s0), va_get_mem(va_s0), va_get_mem(va_sM))
  ensures  va_state_eq(va_sM, va_update_mem(va_sM, va_update_ok(va_sM, va_s0)))
{
  reveal_va_code_CastBytesToWords();
  var va_old_s:va_state := va_s0;
  ghost var va_ltmp1, va_cM:va_code, va_ltmp2 := va_lemma_block(va_b0, va_s0, va_sN);
  va_sM := va_ltmp1;
  va_bM := va_ltmp2;
  var va_b1:va_codes := va_get_block(va_cM);
  va_sM := va_lemma_empty(va_s0, va_sM);

  var addr := va_get_reg64(X86R10, va_s0);
  var old_mem := va_get_mem(va_s0);
  reveal_va_spec_CastBytesToWords();
  reveal_x86_ValidState();
  if va_s0.ok && (exists id :: ValidSrcAddrs(old_mem, id, addr, 8, taint, num_bytes)) 
   && (0 < num_bytes && num_bytes % 4 == 0) {
       var bytes_id :| ValidSrcAddrs(old_mem, bytes_id, addr, 8, taint, num_bytes);
      var heaplets', W_id := lemma_CastBytesToWords(va_s0.heaplets, va_s0.heap, addr, bytes_id, taint, num_bytes);
      va_sM := va_s0.(heaplets := heaplets');
      reveal_x86_ValidState();
      forall id | id in old_mem && AddrInHeaplet(addr, old_mem[id])
          ensures id == bytes_id;
      {
      }
      assert CastBytesResult(bytes_id, old_mem, va_get_mem(va_sM), addr, num_bytes, W_id, taint); // OBSERVE

   } else {
   }
}

lemma va_lemma_CastBytesToWords(va_b0:va_codes, va_s0:va_state, va_sN:va_state, num_bytes:uint32,
  taint:taint)
  returns (va_bM:va_codes, va_sM:va_state)
  requires va_require(va_b0, va_code_CastBytesToWords(num_bytes, taint), va_s0, va_sN)
  ensures  va_ensure(va_b0, va_bM, va_s0, va_sM, va_sN)
  requires va_get_ok(va_s0)
  ensures  va_get_ok(va_sM)
  requires exists id :: ValidSrcAddrs(va_get_mem(va_s0), id, va_get_reg64(X86R10, va_s0), 8, taint,
    num_bytes)
  requires 0 < num_bytes && num_bytes % 4 == 0
  ensures  exists bytes_id, W_id :: CastBytesResult(bytes_id, va_get_mem(va_s0), va_get_mem(va_sM),
    va_get_reg64(X86R10, va_s0), num_bytes, W_id, taint) && (forall id :: id in va_get_mem(va_s0)
    && AddrInHeaplet(va_get_reg64(X86R10, va_s0), va_get_mem(va_s0)[id]) ==> id == bytes_id)
  ensures  va_state_eq(va_sM, va_update_mem(va_sM, va_update_ok(va_sM, va_s0)))
{
  reveal_va_spec_CastBytesToWords();
  va_bM, va_sM := va_refined_CastBytesToWords(va_b0, va_s0, va_sN, num_bytes, taint);
}

predicate CastBytesResult(bytes_id:heaplet_id, va_old_mem:Heaplets, mem:Heaplets, va_old_edi:int, 
                          num_bytes:uint32, W_id:heaplet_id, taint:taint)
{
    bytes_id in va_old_mem 
 && ValidSrcAddrs(va_old_mem, bytes_id, va_old_edi, 8, taint, num_bytes)
 && W_id !in va_old_mem && W_id in mem && IsWordHeaplet(mem[W_id]) 
 && var new_bytes := CastBytesToWordsSrc(va_old_edi, va_old_mem[bytes_id], EmptyWordHeaplet(), num_bytes / 4); 
    var new_words := CastBytesToWordsDst(va_old_edi, va_old_mem[bytes_id], EmptyWordHeaplet(), num_bytes / 4); 
    mem == va_old_mem[W_id := new_words][bytes_id := new_bytes]
 && ValidSrcAddrs(mem, W_id, va_old_edi, 32, taint, num_bytes)
}

#endverbatim

procedure {:refined}{:bridge} CastBytesToWords(inline num_bytes:uint32, inline taint:taint)
  requires
      exists id :: ValidSrcAddrs(mem, id, r10, 8, taint, num_bytes); 
      0 < num_bytes && num_bytes % 4 == 0;
  reads
      r10; 
  modifies 
      mem; 
  ensures
      exists bytes_id, W_id ::
          CastBytesResult(bytes_id, old(mem), mem, old(r10), num_bytes, W_id, taint)
      && (forall id :: old(mem)?[id] && AddrInHeaplet(old(r10), old(mem)[id]) ==> id == bytes_id);
  extern;


// Entry-point for the Dafny-level SHA code
// Wrapper around the internal version
// This handles taking arguments off the stack and casting bytes to words
// Calling convention:
// rcx/rdi = bytes_ptr
// rdx/rsi = offset
// r8 /rdx = W
procedure SHA256_ComputeInitialWs(
  ghost bytes_id:heaplet_id,  // Message bytes
  ghost W_id:heaplet_id,      // Expanded message words
  inline bytes_taint:taint,
  inline win:bool
)
  requires
    // Vale requirements
    //HasStackSlots(stack, 9 + 7);
    let bytes_ptr := if win then rcx else rdi in
    let offset    := if win then rdx else rsi in
    let W_ptr     := if win then r8  else rdx in 
         ValidSrcAddrs(mem, bytes_id, bytes_ptr + offset, 8, bytes_taint, 64)
      && ValidDstAddrs(mem, W_id, W_ptr, 32, 256)
      && W_ptr % 4 == 0
      && bytes_ptr + offset + 64 < 0x1_0000_0000_0000_0000;
  requires
    bytes_id != W_id;
  reads
    rdi; rsi;
  modifies
    mem; r8; rcx; rdx; r10; r9; efl;
    eax; r8d; ecx; edx; r11d;
  ensures
    // Vale stack framing
    //HasStackSlots(stack, 9 + 7);
    //forall slot :: HasStackSlot(old(stack), slot) <==> HasStackSlot(stack, slot);
    //forall slot :: HasStackSlot(stack, slot) && slot >= 9 + 7 ==> stack[0][slot] == old(stack[0][slot]);
    //SeqTail(stack, 1) == old(SeqTail(stack, 1));

    // Calling convention
//    r8d == old(r8d);
//    r9d == old(r9d);
//    r10d == old(r10d);
//    r11d == old(r11d);

    let bytes_ptr := if win then old(rcx) else old(rdi) in
    let offset    := if win then old(rdx) else old(rsi) in
    let W_ptr     := if win then old(r8)  else old(rdx) in 

        // Vale heap framing
        ValidSrcAddrs(mem, W_id, W_ptr, 32, bytes_taint, 256)
     && (forall id :: old(mem)?[id] ==> mem?[id] && (id != bytes_id && id != W_id ==> mem[id] == old(mem)[id]))
     && mem[bytes_id] == CastBytesToWordsSrc(bytes_ptr + offset, old(mem)[bytes_id], EmptyWordHeaplet(), 16)
     && (forall a :: (a < W_ptr || a >= W_ptr + 256) && old(mem)[W_id].words?[a] 
                 ==> mem[W_id].words?[a] && mem[W_id].words[a] == old(mem)[W_id].words[a])

      // SHA                                    // W[t] == BSwap(M[t]);
     && (forall i :: 0 <= i < 64 && i % 4 == 0 ==> mem[W_id].words[W_ptr + i] 
                                                == WordHeapletEntry(old(GetBytesToWord(mem, bytes_id, bytes_ptr + offset + i)), bytes_taint))
     && (forall t:uint32 {TStep(t)} :: 
             0 <= t < 48 && TStep(t)
         ==> (let W := mem[W_id].words in
                 W[W_ptr + 4*(t + 16)].v == 
                   BitwiseAdd32(BitwiseAdd32(BitwiseAdd32(SSIG1(W[W_ptr + 4*(t + 14)].v), 
                                                          W[W_ptr + 4*(t + 9)].v), 
                                             SSIG0(W[W_ptr + 4*(t + 1)].v)), 
                                W[W_ptr + 4*t].v)
                 &&
                 W[W_ptr + 4*(t + 16)].t == bytes_taint));
{
    // Save registers
//    StoreStack(9 + 3, r11d); 
//    StoreStack(9 + 4, r8d);
//    StoreStack(9 + 5, r9d);
//    StoreStack(9 + 6, r10d);

    inline if (win)
    {
        Mov64(r10, rcx);  // r10 := bytes_ptr
        //LoadStack(eax, 9 + 1);  // eax := offset
        Add64(r10, rdx);    // r10 := bytes_ptr + offset
        Mov64(r9, r8);  // r9 := W_ptr;
    }
    else
    {
        Mov64(r10, rdi);  // r10 := bytes_ptr
        Add64(r10, rsi);  // r10 := bytes_ptr + offset
        Mov64(r9, rdx);   // r9 := W_ptr;
    }

    ghost var pre_cast_mem := mem;
    assert ValidSrcAddrs(mem, bytes_id, r10, 8, bytes_taint, 64);
    CastBytesToWords(64, bytes_taint);

    exists b_id, M_id :: CastBytesResult(b_id, pre_cast_mem, mem, r10, 64, M_id, bytes_taint);

    ghost var bytes := if (win) then old(rcx + rdx) else old(rsi + rdi);
    forall i :| 0 <= i < 64 && i % 4 == 0 ::
        mem[M_id].words[bytes + i] == 
        WordHeapletEntry(old(BytesToWord(mem[bytes_id].bytes[bytes + i + 3].v,
                                         mem[bytes_id].bytes[bytes + i + 2].v,
                                         mem[bytes_id].bytes[bytes + i + 1].v,
                                         mem[bytes_id].bytes[bytes + i + 0].v)), bytes_taint)
    {
      ghost var addr := bytes + i;
      assert ValidDstAddr(old(mem), bytes_id, addr,     8);   // OBSERVE
      assert ValidDstAddr(old(mem), bytes_id, addr + 1, 8);   // OBSERVE
      assert ValidDstAddr(old(mem), bytes_id, addr + 2, 8);   // OBSERVE
      assert ValidDstAddr(old(mem), bytes_id, addr + 3, 8);   // OBSERVE
    }

    // HACK: clear upper 32 bits of registers to satisfy precondition:
    Mov32(eax, 0);
    Mov32(ecx, 0);
    Mov32(edx, 0);
    Mov32(r8d, 0);
    Mov32(r11d, 0);

    SHA256_ComputeInitialWs_internal(M_id, W_id, bytes_taint);

    ghost var bytes_ptr := if (win) then old(rcx) else old(rdi);
    ghost var offset := if (win) then old(rdx) else old(rsi);
    ghost var W_ptr := if (win) then old(r8) else old(rdx);
    forall i :| 0 <= i < 64 && i % 4 == 0 ::
        mem[W_id].words[W_ptr + i] == 
        WordHeapletEntry(old(GetBytesToWord(mem, bytes_id, bytes_ptr + offset + i)), bytes_taint)
    {
        ghost var addr := bytes_ptr + offset + i;
        assert ValidDstAddr(old(mem), bytes_id, addr,     8);   // OBSERVE
        assert ValidDstAddr(old(mem), bytes_id, addr + 1, 8);   // OBSERVE
        assert ValidDstAddr(old(mem), bytes_id, addr + 2, 8);   // OBSERVE
        assert ValidDstAddr(old(mem), bytes_id, addr + 3, 8);   // OBSERVE
        lemma_BytesToWord_WordToBytes_inverses(old(mem)[bytes_id].bytes[addr+3].v, old(mem)[bytes_id].bytes[addr+2].v, old(mem)[bytes_id].bytes[addr+1].v, old(mem)[bytes_id].bytes[addr].v);
    }

    // Restore registers
//    LoadStack(r11d, 9 + 3);
//    LoadStack(r8d, 9 + 4);
//    LoadStack(r9d, 9 + 5);
//    LoadStack(r10d, 9 + 6);

    // Scrub the stack
//    StoreStack(9 + 3, 0); 
//    StoreStack(9 + 4, 0);
//    StoreStack(9 + 5, 0);
//    StoreStack(9 + 6, 0);
}

#verbatim
} // end module sha256_vale
#endverbatim
