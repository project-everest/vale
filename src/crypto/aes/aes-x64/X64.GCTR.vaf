include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include "X64.AES.vaf"

module X64.GCTR

#verbatim{:interface}{:implementation}
open Words_s
open Types_s
open Types_i
open FStar.Seq
open AES_s
open X64.AES
open GCTR_s
open GCTR_i
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
#endverbatim

#reset-options "--z3rlimit 40"

///////////////////////////
// GCTR encryption
///////////////////////////

procedure {:quick} init_ctr()
    modifies xmm4; efl;
    ensures 
        xmm4 == Mkfour(1, 0, 0, 0);
{
    Pxor(xmm4, xmm4);
    Pinsrd(xmm4, 1, 0);

    lemma_quad32_xor();
}

procedure {:quick exportOnly} init_pshufb_mask(inout dst:xmm)
    modifies efl;
    ensures
        dst == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
{
    // TODO: Add an instruction to simplify this
    Pinsrd(dst, 0x0C0D0E0F, 0);
    Pinsrd(dst, 0x08090A0B, 1);
    Pinsrd(dst, 0x04050607, 2);
    Pinsrd(dst, 0x00010203, 3);
}

procedure {:quick exportOnly} inc32(inout dst:xmm)
    requires
        xmm4 == Mkfour(1, 0, 0, 0);
    reads
        xmm4;
    modifies 
        efl;
    ensures 
        dst == inc32(old(dst), 1);
{
    Paddd(dst, xmm4);
}

// GCTR encrypt one block
procedure {:quick} gctr_register(
    ghost key:aes_key(AES_128),
    ghost round_keys:seq(quad32),
    ghost keys_b:buffer128
    )
    lets io @= xmm1; icb @= xmm7;
    reads r8; icb; mem;
    modifies
        xmm0; xmm1; xmm2; efl;

    requires
        // AES reqs
        length(round_keys) == 11;
        round_keys == key_to_round_keys(AES_128, reverse_bytes_nat32_seq(key));
        r8 == buffer_addr(keys_b);
        validSrcAddrs128(mem, r8, keys_b, 11);
        buffer128_as_seq(mem, keys_b) == round_keys;
    ensures
        create(1, io) == gctr_encrypt(icb, create(1, old(io)), AES_128, key);
        icb.lo1 == old(icb.lo1);
        icb.hi2 == old(icb.hi2);
        icb.hi3     == old(icb.hi3);
{
    Mov128(xmm0, icb);
    init_pshufb_mask(xmm2);
    Pshufb(xmm0, xmm2);
    AES128EncryptBlock(reverse_bytes_quad32(icb), reverse_bytes_nat32_seq(key), round_keys, keys_b);

    Pxor(xmm1, xmm0);

    // Call a helpful lemma
    gctr_encrypt_one_block(icb, old(io), AES_128, key);
}

procedure {:quick} gctr_core(
    ghost in_b:buffer128,
    ghost out_b:buffer128,
    ghost key:aes_key(AES_128),
    ghost round_keys:seq(quad32),
    ghost keys_b:buffer128
    )
    lets in_ptr @= rax; out_ptr @= rbx; len @= rcx; icb @= xmm7;

    reads
        r8; in_ptr; out_ptr; len; 

    modifies
        rdx; r9; r10; xmm0; xmm1; xmm2; xmm4; icb; mem; efl;

    requires
        // GCTR reqs
        buffers_disjoint128(in_b, out_b);
        buffers_disjoint128(keys_b, out_b);
        validSrcAddrs128(mem, in_ptr, in_b, len);
        validDstAddrs128(mem, out_ptr, out_b, len);
        in_ptr  + 16 * len < pow2_64;
        out_ptr + 16 * len < pow2_64;
        buffer_length(in_b) == buffer_length(out_b) /\ buffer_length(out_b) == len /\ 256 * buffer_length(in_b) < pow2_32;

        // AES reqs
        length(round_keys) == 11;
        round_keys == key_to_round_keys(AES_128, reverse_bytes_nat32_seq(key));
        r8 == buffer_addr(keys_b);
        validSrcAddrs128(mem, r8, keys_b, 11);
        buffer128_as_seq(mem, keys_b) == round_keys;
    ensures
        modifies_buffer128(out_b, old(mem), mem);
        validSrcAddrs128(mem, out_ptr, out_b, len);
        buffer128_as_seq(mem, out_b) == gctr_encrypt(old(icb), buffer128_as_seq(old(mem), in_b), AES_128, key);
        icb.lo1 == old(icb.lo1);
        icb.hi2 == old(icb.hi2);
        icb.hi3     == old(icb.hi3);
{
    Mov64(rdx, 0);
    Mov64(r9, in_ptr);
    Mov64(r10, out_ptr);

    init_ctr();
    init_pshufb_mask(xmm1);

    while (rdx != len)
        invariant
            //////////////////// Basic indexing //////////////////////
            0 <= rdx <= len;
            r9 == in_ptr + 16 * rdx;
            r10 == out_ptr + 16 * rdx;
            icb == inc32(old(icb), rdx);
            
            //////////////////// From requires //////////////////////
            // GCTR reqs
            buffers_disjoint128(in_b, out_b);
            buffers_disjoint128(keys_b, out_b);
            validSrcAddrs128(mem, in_ptr, in_b, len);
            validDstAddrs128(mem, out_ptr, out_b, len);
            in_ptr  + 16 * len < pow2_64;
            out_ptr + 16 * len < pow2_64;

            // AES reqs
            length(round_keys) == 11;
            round_keys == key_to_round_keys(AES_128, reverse_bytes_nat32_seq(key));
            r8 == buffer_addr(keys_b);
            validSrcAddrs128(mem, r8, keys_b, 11);
            buffer128_as_seq(mem, keys_b) == round_keys;

            //////////////////// GCTR invariants //////////////////////
            xmm1 == Mkfour(0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203);
            xmm4 == Mkfour(1, 0, 0, 0);

            //////////////////// Postcondition goals //////////////////////
            modifies_buffer128(out_b, old(mem), mem);
            validSrcAddrs128(mem, out_ptr, out_b, len);
            gctr_partial(rdx, buffer128_as_seq(mem, in_b), buffer128_as_seq(mem, out_b), key, old(icb));
//            forall j :: 0 <= j < rdx ==> 
//                        buffer128_read(out_b, j, mem) == 
//                        quad32_xor(index_workaround(buffer128_as_seq(mem, in_b), j), aes_encrypt(AES_128, key, inc32(old(icb), j)));

        decreases
            len - rdx;
    {
        Mov128(xmm0, icb);
        Pshufb(xmm0, xmm1);
        AES128EncryptBlock(reverse_bytes_quad32(icb), reverse_bytes_nat32_seq(key), round_keys, keys_b);

        Load128_buffer(xmm2, r9, 0, in_b, rdx);
        Pxor(xmm2, xmm0);
        Store128_buffer(r10, xmm2, 0, out_b, rdx);

        Add64(rdx, 1);
        Add64(r9, 16);
        Add64(r10, 16);
        inc32(icb);
    }
    
    // Call a helpful lemma
    gctr_partial_completed(buffer128_as_seq(mem, in_b), buffer128_as_seq(mem, out_b), key, old(icb));
}
