include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include "X64.GF128_Mul.vaf"

module X64.GHash

#verbatim{:interface}{:implementation}
open FStar.Seq
open Words_s
open Types_s
open Types_i
open AES_s
open GHash_s
open GHash_i
open GF128_s
open GF128_i
open Math.Poly2_s
open X64.GF128_Mul
open X64.Machine_s
open X64.Vale.State_i
open X64.Vale.Decls_i
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode_i
open X64.Vale.QuickCodes_i
#endverbatim

#verbatim{:interface}
let get_last_slice_workaround (s:seq quad32) (start_pos end_pos:int)  =
  if 0 <= start_pos && start_pos < end_pos && end_pos <= length s then
    last (slice s start_pos end_pos)
  else
    Mkfour 0 0 0 0 

let slice_workaround (s:seq quad32) (start_pos end_pos:int)  =
  if 0 <= start_pos && start_pos < end_pos && end_pos <= length s then
    slice s start_pos end_pos
  else
    create 1 (Mkfour 0 0 0 0)
#endverbatim

#reset-options "--z3rlimit 40"

///////////////////////////
// GHash
///////////////////////////

procedure {:quick} compute_Y0()
    modifies xmm1; efl;
    ensures xmm1 == Mkfour(0, 0, 0, 0);
{
    Pxor(xmm1, xmm1);
    lemma_quad32_xor();
}

procedure {:quick} compute_ghash_incremental(
    ghost in_b:buffer128
    )
    lets in_ptr @= rax; len @= rcx; io @= xmm1; h @= xmm11;

    reads
        in_ptr; len; h;
        mem;

    modifies
        rdx; r9; xmm2; 
        io; efl;

        // ReduceMulRev128 touches almost everything
        xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; 

    requires
        // GHash reqs
        len > 0 ==> validSrcAddrs128(mem, in_ptr, in_b, len);
        len > 0 ==> in_ptr  + 16 * len < pow2_64;
        len > 0 ==> buffer_length(in_b) == len;

    ensures
        len == 0 ==> rdx == old(rdx) /\ r9 == old(r9) /\ xmm1 == old(xmm1) /\ io == old(io);
        len > 0 ==> length(buffer128_as_seq(mem, in_b)) > 0 /\ io == ghash_incremental(h, old(io), buffer128_as_seq(mem, in_b));
{
    if (len != 0) {
        Mov64(rdx, 0);
        Mov64(r9, in_ptr);

        while (rdx != len)
            invariant
                //////////////////// Basic indexing //////////////////////
                0 <= rdx <= len;
                r9 == in_ptr + 16 * rdx;
                
                //////////////////// From requires //////////////////////
                // GHash reqs
                validSrcAddrs128(mem, in_ptr, in_b, len);
                in_ptr  + 16 * len < pow2_64;
                len > 0;
                buffer_length(in_b) == len;

                //////////////////// Postcondition goals //////////////////////
                rdx == 0 ==> io == old(io);
                rdx > 0 ==> io == ghash_incremental(h, old(io), slice_workaround(buffer128_as_seq(mem, in_b), 0, rdx));

            decreases
                len - rdx;
        {
            Load128_buffer(xmm2, r9, 0, in_b, rdx);
            Pxor(io, xmm2);        // Y_i := Y_{i-1} ^ x_i
            Mov128(xmm2, h);       // xmm2 := H

            lemma_to_of_quad32(xmm1);   // Help satisfy precondition
            lemma_to_of_quad32(xmm2);   // Help satisfy precondition
            ReduceMulRev128(gf128_of_quad32(xmm1), gf128_of_quad32(xmm2));  // io := Y_i * H

            Add64(rdx, 1);
            Add64(r9, 16);
        }
    }
}


procedure {:quick} compute_ghash_incremental_register()
    lets input @= xmm2; io @= xmm1; h @= xmm11;
    reads
        input; h;
    modifies
        io; efl;
        xmm2; xmm3; xmm4; xmm5; xmm6; 
    ensures
        io == ghash_incremental(h, old(io), create(1, old(input)));
{
    Pxor(io, input);    // Y_i := Y_{i-1} ^ x_i
    Mov128(xmm2, h);    // Move h into the register that ReduceMulRev128 expects

    lemma_to_of_quad32(io);   // Help satisfy precondition
    lemma_to_of_quad32(h);    // Help satisfy precondition
    ReduceMulRev128(gf128_of_quad32(io), gf128_of_quad32(h));    // io := Y_i * H
}


procedure {:quick} ghash_core(
    ghost in_b:buffer128
    )
    lets in_ptr @= rax; len @= rcx; output @= xmm1; h @= xmm11;

    reads
        in_ptr; len; h;
        mem;

    modifies
        rdx; r9; xmm2; 
        output; efl;

        // ReduceMulRev128 touches almost everything
        xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; 
    requires
        // GHash reqs
        len > 0 ==> validSrcAddrs128(mem, in_ptr, in_b, len);
        len > 0 ==> in_ptr  + 16 * len < pow2_64;
        len > 0 ==> buffer_length(in_b) == len;

    ensures
        len == 0 ==> rdx == old(rdx) /\ r9 == old(r9) /\ xmm1 == old(xmm1) /\ output == old(output);
        len > 0 ==> length(buffer128_as_seq(mem, in_b)) > 0 /\ output == ghash(h, buffer128_as_seq(mem, in_b));
{
    if (len != 0) {
        compute_Y0();
        compute_ghash_incremental(in_b);
        ghash_incremental_to_ghash(old(h), buffer128_as_seq(mem, in_b));
    }
}

