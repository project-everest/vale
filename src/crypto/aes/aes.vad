include "../../arch/x86/decls.vad"
include{:verbatim} "../../arch/x86/print.s.dfy"
include{:verbatim} "../../lib/util/dafny_wrappers.i.dfy"
include{:verbatim} "aes_lemmas.i.dfy"
include{:verbatim} "aes_helpers.i.dfy"

#verbatim
module aes_vale {

import opened x86_def_s
import opened x86_vale_i
import opened x86_print_s
import opened dafny_wrappers_i
import opened x86_decls_i
import opened AESLemmasModule

#endverbatim

///////////////////////////
// KEY EXPANSION
///////////////////////////

procedure {:refined} {:timeLimitMultiplier 2} KeyExpansionRound(
    inline round:uint32,
    inline rcon:imm8,
    inline taint:taint,
    ghost dst_id:heaplet_id,
    ghost key:seq(uint32),
    ghost w_in:seq(uint32)
    ) returns (
    ghost w_out:seq(uint32)
    )
    requires/ensures
        ValidDstAddrs(mem, dst_id, eax, 128, 16*11);
    requires
        0 <= round < 10;
        rcon == AES_Rcon()[round];
        SeqLength(key) == 4;
        SeqLength(w_in) == 44;
        KeyExpansionPredicatePartial(key, AES_128, w_in, 4+round*4);
        eax % 16 == 0;
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16*(round+1));
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
        xmm1 == mem[dst_id].quads[eax + 16*round].v;
    reads
        eax;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    ensures
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16*(round+2));
        mem == old(mem)[dst_id := mem[dst_id]];
        xmm1 == mem[dst_id].quads[eax + 16*(round+1)].v;
        forall a :: (a < eax || a >= eax + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
        SeqLength(w_out) == 44;
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
        KeyExpansionPredicatePartial(key, AES_128, w_out, 4+(round+1)*4);
{
    ghost var xmm1_v0 := xmm1;

    AESNI_keygen_assist(xmm2, xmm1, rcon);
    ghost var xmm2_v1 := xmm2;

    Pshufd(xmm2, xmm2, 255);
    ghost var xmm2_v2 := xmm2;

    VPSLLDQ4(xmm3, xmm1);
    ghost var xmm3_v3 := xmm3;

    Pxor(xmm1,xmm3);
    ghost var xmm1_v4 := xmm1;

    VPSLLDQ4(xmm3, xmm1);
    ghost var xmm3_v5 := xmm3;

    Pxor(xmm1,xmm3);
    ghost var xmm1_v6 := xmm1;

    VPSLLDQ4(xmm3, xmm1);
    ghost var xmm3_v7 := xmm3;

    Pxor(xmm1,xmm3);
    ghost var xmm1_v8 := xmm1;

    Pxor(xmm1,xmm2);
    ghost var xmm1_v9 := xmm1;

    Store128(eax, xmm1, 16*(round+1), taint, dst_id);

    ghost var new_round := round + 1;
    w_out := w_in[new_round*4     := xmm1.lo]
                 [new_round*4 + 1 := xmm1.mid_lo]
                 [new_round*4 + 2 := xmm1.mid_hi]
                 [new_round*4 + 3 := xmm1.hi];

    forall j :| 0 <= j <= 10 :: mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3])
    {
        assert j == new_round ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
        assert j != new_round ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
    }

    ghost var alg := AES_128();
    lemma_AES128Size(alg);
    lemma_KeyExpansionRoundHelper(key, alg, w_in, 4+round*4, xmm1_v0, xmm2_v1, xmm2_v2, xmm3_v3, xmm1_v4, xmm3_v5, xmm1_v6, xmm3_v7, xmm1_v8, xmm1_v9, w_out);
}

#verbatim

function method AES_Rcon_Case(i:int) : uint32
    requires 0 <= i < 10;
    ensures  AES_Rcon_Case(i) == AES_Rcon()[i];
{
    if i == 0 then 0x01 else if i == 1 then 0x02 else if i == 2 then 0x04 else if i == 3 then 0x08 else if i == 4 then 0x10 else if i == 5 then 0x20 else if i == 6 then 0x40 else if i == 7 then 0x80 else if i == 8 then 0x1b else 0x36
}

#endverbatim

procedure {:refined} {:recursive} KeyExpansionRoundUnrolledRecursive(
    ghost key:seq(uint32), 
    ghost w_in:seq(uint32),
    inline taint:taint,
    ghost dst_id:heaplet_id,
    inline n:int
    ) returns (
    ghost w_out:seq(uint32)
    )
    reads
        eax;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires/ensures
        ValidDstAddrs(mem, dst_id, eax, 128, 16*11);
        eax % 16 == 0;
    requires
        0 <= n <= 10;
        SeqLength(key) == 4;
        xmm1 == seq_to_Quadword(key);
        SeqLength(w_in) == 44;
        KeyExpansionPredicatePartial(key, AES_128, w_in, 4);
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16);
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
    ensures
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16*(n+1));
        mem == old(mem)[dst_id := mem[dst_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
        SeqLength(w_out) == 44;
        xmm1 == Quadword(w_out[4*n], w_out[4*n + 1], w_out[4*n + 2], w_out[4*n + 3]);
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
        KeyExpansionPredicatePartial(key, AES_128, w_out, 4 + 4*n);
{
    inline if (0 < n <= 10) {
        ghost var w_mid:seq(uint32);
        w_mid := KeyExpansionRoundUnrolledRecursive(key, w_in, taint, dst_id, n-1);
        w_out := KeyExpansionRound(n-1, AES_Rcon_Case(n-1), taint, dst_id, key, w_mid);
    }
    else {
        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 0);
        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 1);
        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 2);
        assert KeyExpansionPredicateSpecific(key, AES_128, w_in, 3);
        w_out := w_in;
    }
}

procedure {:refined} KeyExpansionRoundUnrolled(
    ghost key:seq(uint32), 
    ghost w_in:seq(uint32),
    inline taint:taint,
    ghost dst_id:heaplet_id
    ) returns (
    ghost w_out:seq(uint32)
    )
    reads
        eax;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires/ensures
        ValidDstAddrs(mem, dst_id, eax, 128, 16*11);
        eax % 16 == 0;
    requires
        SeqLength(key) == 4;
        xmm1 == seq_to_Quadword(key);
        SeqLength(w_in) == 44;
        KeyExpansionPredicatePartial(key, AES_128, w_in, 4);
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16);
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3]);
    ensures
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16*11);
        mem == old(mem)[dst_id := mem[dst_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
        SeqLength(w_out) == 44;
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w_out[4*j], w_out[4*j+1], w_out[4*j+2], w_out[4*j+3]);
        KeyExpansionPredicate(key, AES_128, w_out);
{
    w_out := KeyExpansionRoundUnrolledRecursive(key, w_in, taint, dst_id, 10);
}

procedure {:refined} {:timeLimitMultiplier 3} KeyExpansionImpl(
    ghost key:seq(uint32),
    inline taint:taint,
    ghost dst_id:heaplet_id
    ) returns (
    ghost w:seq(uint32)
    )
    reads
        eax;
    modifies
        mem; xmm1; xmm2; xmm3; efl;
    requires
        SeqLength(key) == 4;
        xmm1 == seq_to_Quadword(key);
        ValidDstAddrs(mem, dst_id, eax, 128, 16*11);
        eax % 16 == 0;
    ensures
        ValidSrcAddrs(mem, dst_id, eax, 128, taint, 16*11);
        mem == old(mem)[dst_id := mem[dst_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[dst_id].quads?[a] ==> mem[dst_id].quads?[a] && mem[dst_id].quads[a] == old(mem)[dst_id].quads[a];
        SeqLength(w) == 44;
        forall j :: 0 <= j <= 10 ==> mem[dst_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, AES_128, w);
{
    Store128(eax, xmm1, 16*0, taint, dst_id);

    ghost var w_in := Quadword_to_seq(mem[dst_id].quads[eax + 16* 0].v) 
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 1].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 2].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 3].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 4].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 5].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 6].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 7].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 8].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16* 9].v)
                    + Quadword_to_seq(mem[dst_id].quads[eax + 16*10].v);

    forall j :| 0 <= j <= 10 :: mem[dst_id].quads[eax + 16*j].v == Quadword(w_in[4*j], w_in[4*j+1], w_in[4*j+2], w_in[4*j+3])
    {
    }

    w := KeyExpansionRoundUnrolled(key, w_in, taint, dst_id);
}

procedure {:refined} KeyExpansionStdcall(
    inline taint:taint,
    ghost input_key_id:heaplet_id,
    ghost output_key_expansion_id:heaplet_id
    ) returns (
    ghost w:seq(uint32)
    )
    reads
        stack;
    modifies
        mem; eax; xmm1; xmm2; xmm3; efl;
    requires
        HasStackSlots(stack, 2);
        let key_ptr := stack[0][0] in
        let key_expansion_ptr := stack[0][1] in
           key_ptr % 16 == 0
        && key_expansion_ptr % 16 == 0
        && ValidSrcAddr(mem, input_key_id, key_ptr, 128, taint)
        && ValidDstAddrs(mem, output_key_expansion_id, key_expansion_ptr, 128, 176);
    ensures
        SeqLength(w) == 44;
        let key_ptr := old(stack[0][0]) in
        let key_expansion_ptr := old(stack[0][1]) in
        let key := Quadword_to_seq(old(mem)[input_key_id].quads[key_ptr].v) in
           ValidSrcAddrs(mem, output_key_expansion_id, key_expansion_ptr, 128, taint, 176)
        && mem == old(mem)[output_key_expansion_id := mem[output_key_expansion_id]]
        && (forall a :: (a < key_expansion_ptr || a >= key_expansion_ptr + 176) && old(mem)[output_key_expansion_id].quads?[a] ==> mem[output_key_expansion_id].quads?[a] && mem[output_key_expansion_id].quads[a] == old(mem)[output_key_expansion_id].quads[a])
        && (forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]))
        && KeyExpansionPredicate(key, AES_128, w);
{
    ghost var key_ptr := stack[0][0];
    ghost var key_expansion_ptr := stack[0][1];
    ghost var key := Quadword_to_seq(mem[input_key_id].quads[key_ptr].v);

    LoadStack(eax, 0);                                     // eax := key_ptr (from stack position 0)
    Load128(xmm1, eax, 0, taint, input_key_id);            // xmm1 = contents of eax as Quadword pointer
    LoadStack(eax, 1);                                     // eax := key_expansion_ptr (from stack position 1)
    assert eax == key_expansion_ptr;
    w := KeyExpansionImpl(key, taint, output_key_expansion_id); // expand key from xmm1 to region pointed to by eax
    assert eax == key_expansion_ptr;

    assert SeqLength(w) == 44;
    assert forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
    assert KeyExpansionPredicate(key, AES_128, w);

    forall j :| 0 <= j <= 10 :: mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3])
    {
        assert mem[output_key_expansion_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        assert eax == key_expansion_ptr;
    }

    // Clear secrets out of registers
    Xor32(eax, eax);
    Pxor(xmm1, xmm1);
    Pxor(xmm2, xmm2);
    Pxor(xmm3, xmm3);
}

///////////////////////////
// ENCRYPTION
///////////////////////////

procedure {:refined} AES128EncryptFirstStep(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem; 
    modifies
        xmm0; xmm2; efl;
    requires/ensures
      SeqLength(key) == 4;
      SeqLength(w) == 44;
      KeyExpansionPredicate(key, AES_128, w);
      ValidSrcAddr(mem, K_id, eax, 128, taint);
      mem[K_id].quads[eax].v == Quadword(w[0], w[1], w[2], w[3]);
    ensures
      SeqLength(xmm0_trace_out) == 1;
      xmm0_trace_out[0] == xmm0;
      IsValidAES128EncryptionTracePrefix(key, w, old(xmm0), xmm0_trace_out);
{
    // ROUND 0 - XOR

    Load128(xmm2, eax, 0, taint, K_id);
    assert xmm2 == Quadword(w[0], w[1], w[2], w[3]);

    Pxor(xmm0, xmm2);

    xmm0_trace_out := seq(xmm0);
    assert IsValidAES128EncryptionTracePrefix(key, w, old(xmm0), xmm0_trace_out);
}

procedure {:refined} AESEncryptFirstStep(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id,
    ghost alg:Algorithm
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem; 
    modifies
        xmm0; xmm2; efl;
    requires/ensures
      SeqLength(key) == Nk(alg);
      SeqLength(w) == Nb()*(Nr(alg)+1);
      KeyExpansionPredicate(key, alg, w);
      ValidSrcAddr(mem, K_id, eax, 128, taint);
      mem[K_id].quads[eax].v == Quadword(w[0], w[1], w[2], w[3]);
    ensures
      SeqLength(xmm0_trace_out) == 1;
      xmm0_trace_out[0] == xmm0;
      IsValidAESEncryptionTracePrefix(alg, key, w, old(xmm0), xmm0_trace_out);
{
    // ROUND 0 - XOR

    Load128(xmm2, eax, 0, taint, K_id);
    assert xmm2 == Quadword(w[0], w[1], w[2], w[3]);

    Pxor(xmm0, xmm2);

    xmm0_trace_out := seq(xmm0);
    assert IsValidAESEncryptionTracePrefix(alg, key, w, old(xmm0), xmm0_trace_out);
}


procedure {:refined} AES128EncryptMiddleStep(
    inline round:int,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost xmm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl;
    requires
        SeqLength(xmm0_trace_in) == round;
        1 <= round <= 9;
        xmm0_trace_in[round-1] == xmm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_in);
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        ValidSrcAddr(mem, K_id, eax+16*round, 128, taint);
        mem[K_id].quads[eax+16*round].v == Quadword(w[4*round], w[4*round+1], w[4*round+2], w[4*round+3]);
        KeyExpansionPredicate(key, AES_128, w);
    ensures
        SeqLength(xmm0_trace_out) == round + 1;
        xmm0_trace_out[round] == xmm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_out);
{
    ghost var old_xmm0 := xmm0;

    Load128(xmm2, eax, 16*round, taint, K_id);
    assert xmm2 == seq_to_Quadword(SeqRange(w, 4*round, 4*round+4));
    AESNI_enc(xmm0, xmm2);

    ghost var new_xmm0 := xmm0;
    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);

    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, round, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
}

// On entry, eax is the ptr to the expanded key
//           ecx is the number of rounds
//           edx is the round number
// BUGBUG:  xmm0_trace_in must be the second-to-last argument, or else Vale emits a mistmatch between the va_trigger call and implementation
procedure {:refined} AESEncryptMiddleStep(
    inline taint:taint,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost K_id:heaplet_id,
    ghost alg:Algorithm,
    ghost xmm0_trace_in:QuadwordSeq,
    ghost round:int
  ) returns (
    ghost xmm0_trace_out:QuadwordSeq
  )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl; ecx; edx; esi;
    requires
        SeqLength(xmm0_trace_in) == round;
        1 <= round <= Nr(alg)-1;
        xmm0_trace_in[round-1] == xmm0;
        IsValidAESEncryptionTracePrefix(alg, key, w, input, xmm0_trace_in);
        SeqLength(key) == 4;
        SeqLength(w) == 4*(Nr(alg)+1);
        ecx == round;
        ValidSrcAddr(mem, K_id, eax+16*round, 128, taint);
        mem[K_id].quads[eax+16*round].v == Quadword(w[4*round], w[4*round+1], w[4*round+2], w[4*round+3]);
        KeyExpansionPredicate(key, alg, w);
    ensures
        SeqLength(xmm0_trace_out) == round + 1;
        xmm0_trace_out[round] == xmm0;
        IsValidAESEncryptionTracePrefix(alg, key, w, input, xmm0_trace_out);
{
    ghost var old_xmm0 := xmm0;
    
    Mov32(esi, edx);    // edx = round
    Shl32(esi, 4);      // esi = round*16
    Add32(esi, eax);    // esi = &key[round]  // todo: can this be turned into "lea esi, [edx*2] / load128 xmm2, [eax+esi*8]" ?
    Load128(xmm2, esi, 0, taint, K_id);
    assert xmm2 == seq_to_Quadword(SeqRange(w, 4*round, 4*round+4));
    AESNI_enc(xmm0, xmm2);
    Add32(edx, 1);      // Increment round number
    
    ghost var new_xmm0 := xmm0;
    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);
    
    lemma_ExtendingAESEncryptionTracePrefix(alg, key, w, input, round, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
    
}

procedure {:refined} AES128EncryptLastStep(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost xmm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl;
    requires
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        ValidSrcAddr(mem, K_id, eax+16*10, 128, taint);
        mem[K_id].quads[eax+16*10].v == Quadword(w[40], w[41], w[42], w[43]);
        KeyExpansionPredicate(key, AES_128, w);
        SeqLength(xmm0_trace_in) == 10;
        xmm0_trace_in[9] == xmm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_in);
    ensures
        SeqLength(xmm0_trace_out) == 11;
        xmm0_trace_out[10] == xmm0;
        IsValidAES128EncryptionTracePrefix(key, w, input, xmm0_trace_out);
{
    ghost var old_xmm0 := xmm0;

    Load128(xmm2, eax, 16*10, taint, K_id);
    assert xmm2 == seq_to_Quadword(SeqRange(w, 4*10, 4*10+4));
    AESNI_enc_last(xmm0, xmm2);

    ghost var new_xmm0 := xmm0;
    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);

    lemma_ExtendingAES128EncryptionTracePrefix(key, w, input, 10, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
}

// on entry, eax = key pointer, xmm0 = value to encrypt
// on return, xmm0 = encrypted value
procedure {:refined} AES128EncryptOneBlock(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id)
    reads
        mem; eax; 
    modifies
        xmm0; xmm2; efl;
    requires
        eax % 16 == 0;
        SeqLength(key) == 4;
        xmm0 == input;
        SeqLength(w) == 44;
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
        forall j :: 0 <= j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, AES_128, w);
    ensures
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
        xmm0 == AES_Encrypt(key, input, AES_128);
{
    assert mem[K_id].quads[eax + 16* 0].v == Quadword(w[4* 0], w[4* 0+1], w[4* 0+2], w[4* 0+3]);
    ghost var xmm0_trace_step0:QuadwordSeq;
    xmm0_trace_step0 := AES128EncryptFirstStep(key, w, taint, K_id);

    assert mem[K_id].quads[eax + 16* 1].v == Quadword(w[4* 1], w[4* 1+1], w[4* 1+2], w[4* 1+3]);
    ghost var xmm0_trace_step1:QuadwordSeq;
    xmm0_trace_step1 := AES128EncryptMiddleStep(1, key, w, input, xmm0_trace_step0, taint, K_id);

    assert mem[K_id].quads[eax + 16* 2].v == Quadword(w[4* 2], w[4* 2+1], w[4* 2+2], w[4* 2+3]);
    ghost var xmm0_trace_step2:QuadwordSeq;
    xmm0_trace_step2 := AES128EncryptMiddleStep(2, key, w, input, xmm0_trace_step1, taint, K_id);

    assert mem[K_id].quads[eax + 16* 3].v == Quadword(w[4* 3], w[4* 3+1], w[4* 3+2], w[4* 3+3]);
    ghost var xmm0_trace_step3:QuadwordSeq;
    xmm0_trace_step3 := AES128EncryptMiddleStep(3, key, w, input, xmm0_trace_step2, taint, K_id);

    assert mem[K_id].quads[eax + 16* 4].v == Quadword(w[4* 4], w[4* 4+1], w[4* 4+2], w[4* 4+3]);
    ghost var xmm0_trace_step4:QuadwordSeq;
    xmm0_trace_step4 := AES128EncryptMiddleStep(4, key, w, input, xmm0_trace_step3, taint, K_id);

    assert mem[K_id].quads[eax + 16* 5].v == Quadword(w[4* 5], w[4* 5+1], w[4* 5+2], w[4* 5+3]);
    ghost var xmm0_trace_step5:QuadwordSeq;
    xmm0_trace_step5 := AES128EncryptMiddleStep(5, key, w, input, xmm0_trace_step4, taint, K_id);

    assert mem[K_id].quads[eax + 16* 6].v == Quadword(w[4* 6], w[4* 6+1], w[4* 6+2], w[4* 6+3]);
    ghost var xmm0_trace_step6:QuadwordSeq;
    xmm0_trace_step6 := AES128EncryptMiddleStep(6, key, w, input, xmm0_trace_step5, taint, K_id);

    assert mem[K_id].quads[eax + 16* 7].v == Quadword(w[4* 7], w[4* 7+1], w[4* 7+2], w[4* 7+3]);
    ghost var xmm0_trace_step7:QuadwordSeq;
    xmm0_trace_step7 := AES128EncryptMiddleStep(7, key, w, input, xmm0_trace_step6, taint, K_id);

    assert mem[K_id].quads[eax + 16* 8].v == Quadword(w[4* 8], w[4* 8+1], w[4* 8+2], w[4* 8+3]);
    ghost var xmm0_trace_step8:QuadwordSeq;
    xmm0_trace_step8 := AES128EncryptMiddleStep(8, key, w, input, xmm0_trace_step7, taint, K_id);

    assert mem[K_id].quads[eax + 16* 9].v == Quadword(w[4* 9], w[4* 9+1], w[4* 9+2], w[4* 9+3]);
    ghost var xmm0_trace_step9:QuadwordSeq;
    xmm0_trace_step9 := AES128EncryptMiddleStep(9, key, w, input, xmm0_trace_step8, taint, K_id);

    assert mem[K_id].quads[eax + 16*10].v == Quadword(w[4*10], w[4*10+1], w[4*10+2], w[4*10+3]);
    ghost var xmm0_trace_step10:QuadwordSeq;
    xmm0_trace_step10 := AES128EncryptLastStep(key, w, input, xmm0_trace_step9, taint, K_id);

    lemma_AES128Encrypt(key, input, w, xmm0, xmm0_trace_step10);
    assert (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
    assert (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
    assert xmm0 == AES_Encrypt(key, input, AES_128);

    // Clear secrets out of registers
    Pxor(xmm2, xmm2);
}

procedure {:refined} AES128EncryptOneBlockStdcall(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost w:seq(uint32),
    ghost input_id:heaplet_id,
    ghost output_id:heaplet_id,
    ghost K_id:heaplet_id)
    reads
        stack; 
    modifies
        mem; eax; xmm0; xmm2; efl;
    requires
        HasStackSlots(stack, 4);

        // Calling convention
        let output_ptr       := stack[0][0] in
        let input_ptr        := stack[0][1] in
        let expanded_key_ptr := stack[0][2] in

        // Expanded key is readable
           ValidSrcAddrs(mem, K_id, expanded_key_ptr, 128, Secret, 16*11)
        && expanded_key_ptr % 16 == 0
        && SeqLength(key) == 4
        && SeqLength(w) == 44
        // And the expanded key in memory matches the abstract version
        && (forall j :: 0 <= j <= 10 ==> mem[K_id].quads[expanded_key_ptr + 16*j].v
                                      == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]))
        && KeyExpansionPredicate(key, AES_128, w)

        // One block of input is readable
        && ValidSrcAddr(mem, input_id, input_ptr, 128, Secret)
        // And it matches the ghost input
        && mem[input_id].quads[input_ptr].v == input

        // One block of output is writeable
        && ValidDstAddr(mem, output_id, output_ptr, 128);

    ensures
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;

        // Calling convention  (all implied by lack of modifies clause)
//        ebx == old(ebx);
//        esi == old(esi);
//        edi == old(edi);
//        ebp == old(ebp);

        // Output is now readable
        ValidSrcAddr(mem, output_id, old(stack[0][0]), 128, Secret);

        // Stack framing: Nothing changes
        stack == old(stack);

        // Framing: Only the output was changed
        mem == old(mem)[output_id := mem[output_id]];

        // Calling convention
        let output_ptr       := stack[0][0] in
        // Memory contains the proper output value
        mem[output_id].quads[output_ptr].v == AES_Encrypt(key, input, AES_128);

{
    // Load the input
    LoadStack(eax, 1); // eax = input_ptr
    Load128(xmm0, eax, 0, Secret, input_id); // xmm0 = input data value

    // Load a pointer to the expanded key
    LoadStack(eax, 2);

    // Do the work
    //  On entry:  eax = ptr to expanded key, xmm0 = input data value
    //  On return: xmm0 = encrypted data value
    AES128EncryptOneBlock(key, input, w, Secret, K_id);

    // Store the result in the buffer pointed at by the output_ptr on the stack
    LoadStack(eax, 0);  // eax = output_ptr
    Store128(eax, xmm0, 0, Secret, output_id);
}


// on entry, eax = expanded key pointer, xmm0 = value to encrypt, ecx = number of rounds, edx = 1 (rounds completed)
// on return, xmm0 = encrypted value
procedure {:refined} AESEncryptLoop(
    inline taint:taint,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost input:Quadword,
    ghost K_id:heaplet_id,
    ghost alg:Algorithm,
    ghost xmm0_trace_step0:QuadwordSeq
  ) returns (
    ghost xmm0_trace_steps:QuadwordSeq
  )
    reads
        mem; eax;
    modifies
        xmm0; xmm2; efl; ecx; edx;
    requires
        eax % 16 == 0;
        ecx == Nr(alg);
        edx == ecx-1;
        SeqLength(key) == Nk(alg);
        xmm0 == input;
        SeqLength(w) == Nb()*(Nr(alg)+1);
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*(Nr(alg)+1));
        forall j :: 0 <= j <= Nr(alg) ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, alg, w);
    ensures
        (Nb() * (Nr(alg) + 1)) / 4 == Nr(alg) + 1;
        (Nb() * (Nr(alg) + 1)) % 4 == 0;
        xmm0 == AES_Encrypt(key, input, alg);
        edx == 1;
{
    ghost var round:int := 1;
    xmm0_trace_steps := xmm0_trace_step0;
    while (edx < ecx)
      invariant
        old(edx) < edx < ecx;
        round == edx;
      decreases
        ecx - edx;
    {
      xmm0_trace_steps := AESEncryptMiddleStep(taint, key, w, input, K_id, alg, xmm0_trace_steps, round);
      round := round + 1;
    }
}

// on entry, eax = expanded key pointer, xmm0 = value to encrypt, ecx = number of rounds
// on return, xmm0 = encrypted value
procedure {:refined} AESEncryptOneBlock(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id,
    ghost alg:Algorithm)
    reads
        mem; eax; 
    modifies
        xmm0; xmm2; efl; ecx; edx;
    requires
        eax % 16 == 0;
        ecx == Nr(alg);
        SeqLength(key) == Nk(alg);
        xmm0 == input;
        SeqLength(w) == Nb()*(Nr(alg)+1);
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*(Nr(alg)+1));
        forall j :: 0 <= j <= Nr(alg) ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, alg, w);
    ensures
        (Nb() * (Nr(alg) + 1)) / 4 == Nr(alg) + 1;
        (Nb() * (Nr(alg) + 1)) % 4 == 0;
        xmm0 == AES_Encrypt(key, input, alg);
{
    assert mem[K_id].quads[eax + 16* 0].v == Quadword(w[4* 0], w[4* 0+1], w[4* 0+2], w[4* 0+3]);
    ghost var xmm0_trace_step0:QuadwordSeq;
    xmm0_trace_step0 := AESEncryptFirstStep(key, w, taint, K_id, alg);
    
    Mov32(edx, 1); // First step is finished
    Add32Wrap(ecx,0xffffffff); // Stop 1 before the final round, decrement ecx by 1
    ghost var xmm0_trace_steps:QuadwordSeq;
    xmm0_trace_steps := AESEncryptLoop(taint, key, w, input, K_id, alg, xmm0_trace_step0);

    //assert mem[K_id].quads[eax + 16*round].v == Quadword(w[4*round], w[4*round+1], w[4*round+2], w[4*round+3]);
    ghost var xmm0_trace_step_last:QuadwordSeq;
    xmm0_trace_step_last := AES128EncryptLastStep(key, w, input, xmm0_trace_steps, taint, K_id);
    
    lemma_AESEncrypt(alg, key, input, w, xmm0, xmm0_trace_step_last);
    assert (Nb() * (Nr(alg) + 1)) / 4 == Nr(alg) + 1;
    assert (Nb() * (Nr(alg) + 1)) % 4 == 0;
    assert xmm0 == AES_Encrypt(key, input, alg);

    // Clear secrets out of registers
    Pxor(xmm2, xmm2);
}
procedure {:refined} AESEncryptOneBlockStdcall(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost w:seq(uint32),
    ghost input_id:heaplet_id,
    ghost output_id:heaplet_id,
    ghost K_id:heaplet_id)
    reads
        stack; 
    modifies
        mem; eax; xmm0; xmm2; efl; ecx; edx;
    requires
        HasStackSlots(stack, 4);

        // Calling convention
        let output_ptr       := stack[0][0] in
        let input_ptr        := stack[0][1] in
        let expanded_key_ptr := stack[0][2] in

        // Expanded key is readable
           ValidSrcAddrs(mem, K_id, expanded_key_ptr, 128, Secret, 16*11)
        && expanded_key_ptr % 16 == 0
        && SeqLength(key) == 4
        && SeqLength(w) == 44
        // And the expanded key in memory matches the abstract version
        && (forall j :: 0 <= j <= 10 ==> mem[K_id].quads[expanded_key_ptr + 16*j].v
                                      == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]))
        && KeyExpansionPredicate(key, AES_128, w)

        // One block of input is readable
        && ValidSrcAddr(mem, input_id, input_ptr, 128, Secret)
        // And it matches the ghost input
        && mem[input_id].quads[input_ptr].v == input

        // One block of output is writeable
        && ValidDstAddr(mem, output_id, output_ptr, 128);

    ensures
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;

        // Calling convention  (all implied by lack of modifies clause)
//        ebx == old(ebx);  
//        esi == old(esi);  
//        edi == old(edi);  
//        ebp == old(ebp);  
        
        // Output is now readable
        ValidSrcAddr(mem, output_id, old(stack[0][0]), 128, Secret);

        // Stack framing: Nothing changes
        stack == old(stack);

        // Framing: Only the output was changed
        mem == old(mem)[output_id := mem[output_id]];

        // Calling convention
        let output_ptr       := stack[0][0] in
        // Memory contains the proper output value
        mem[output_id].quads[output_ptr].v == AES_Encrypt(key, input, AES_128);
          
{
    // Load the input
    LoadStack(eax, 1); // eax = input_ptr
    Load128(xmm0, eax, 0, Secret, input_id); // xmm0 = input data value

    // Load a pointer to the expanded key
    LoadStack(eax, 2);
    
    Mov32(edx, 10); // bugbug: convert a concrete alg variable into Nr(alg) at runtime

    // Do the work
    //  On entry:  eax = ptr to expanded key, xmm0 = input data value
    //  On return: xmm0 = encrypted data value
    AES128EncryptOneBlock(key, input, w, Secret, K_id);

    // Store the result in the buffer pointed at by the output_ptr on the stack
    LoadStack(eax, 0);  // eax = output_ptr
    Store128(eax, xmm0, 0, Secret, output_id);
}


procedure {:refined} AES128ExpandKeyAndEncryptOneBlock(
    ghost key:seq(uint32),
    ghost input:Quadword,
    inline taint:taint,
    ghost K_id:heaplet_id)
    reads
        eax;
    modifies
        mem; xmm0; xmm1; xmm2; xmm3; efl;
    requires
        eax % 16 == 0;
        SeqLength(key) == 4;
        ValidDstAddrs(mem, K_id, eax, 128, 16*11);
        xmm0 == input;
        xmm1 == seq_to_Quadword(key);
    ensures
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
        mem == old(mem)[K_id := mem[K_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[K_id].quads?[a] ==> mem[K_id].quads?[a] && mem[K_id].quads[a] == old(mem)[K_id].quads[a];
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
        xmm0 == AES_Encrypt(key, input, AES_128);
{
    ghost var w;
    w := KeyExpansionImpl(key, taint, K_id);
    AES128EncryptOneBlock(key, input, w, taint, K_id);
}

///////////////////////////
// KEY INVERSION
///////////////////////////

procedure {:refined} KeyInversionRound(
    inline round:int,
    inline taint:taint,
    ghost K_id:heaplet_id,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost dw_in:seq(uint32)
    ) returns (
    ghost dw_out:seq(uint32)
    )
    requires/ensures
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
    requires
        0 <= round <= 8;
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        SeqLength(dw_in) == 4*(round+1);
        KeyExpansionPredicate(key, AES_128, w);
        EqInvKeyExpansionPredicatePartial(key, AES_128, dw_in, round);
        forall j :: 0 <= j <= round ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw_in[4*j], dw_in[4*j+1], dw_in[4*j+2], dw_in[4*j+3]);
        forall j :: round < j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
    reads 
        eax;
    modifies
        mem; xmm1; efl;
    ensures
        mem == old(mem)[K_id := mem[K_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[K_id].quads?[a] ==> mem[K_id].quads?[a] && mem[K_id].quads[a] == old(mem)[K_id].quads[a];
        forall j :: round+1 < j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        SeqLength(dw_out) == 4*(round + 2);
        forall j :: 0 <= j <= round+1 ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]);
        EqInvKeyExpansionPredicatePartial(key, AES_128, dw_out, round+1);
{
    assert mem[K_id].quads[eax + 16*(round+1)].v == Quadword(w[(round+1)*4], w[(round+1)*4 + 1], w[(round+1)*4 + 2], w[(round+1)*4 + 3]);

    Load128(xmm1, eax, 16*(round+1), taint, K_id);
    assert xmm1 == Quadword(w[(round+1)*4], w[(round+1)*4 + 1], w[(round+1)*4 + 2], w[(round+1)*4 + 3]);
    ghost var ws := SeqRange(w, (round+1)*4, (round+1)*4 + 4);
    assert ws[0] == w[(round+1)*4] && ws[1] == w[(round+1)*4+1] && ws[2] == w[(round+1)*4+2] && ws[3] == w[(round+1)*4+3];
    assert xmm1 == seq_to_Quadword(ws);
    AESNI_imc(xmm1, xmm1);
    Store128(eax, xmm1, 16*(round+1), taint, K_id);

    dw_out := dw_in + Quadword_to_seq(xmm1);
    lemma_KeyInversionRoundHelper(round+1, key, w, dw_in, dw_out);

    forall j :| round+1 < j <= 10 :: mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]) {
    }

    forall j :| 0 <= j <= round + 1 :: mem[K_id].quads[eax + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]) {
    }
}

procedure {:refined} {:recursive} KeyInversionRoundUnrolledRecursive(
    inline rounds:int,
    inline taint:taint,
    ghost K_id:heaplet_id,
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    ghost dw_in:seq(uint32)
    ) returns (
    ghost dw_out:seq(uint32)
    )
    requires/ensures
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
    requires
        0 <= rounds <= 9;
        eax % 16 == 0;
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        SeqLength(dw_in) == 4;
        KeyExpansionPredicate(key, AES_128, w);
        EqInvKeyExpansionPredicatePartial(key, AES_128, dw_in, 0);
        mem[K_id].quads[eax+16*0].v == Quadword(dw_in[4*0], dw_in[4*0+1], dw_in[4*0+2], dw_in[4*0+3]);
        forall j :: 0 <= j <= 0 ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw_in[4*j], dw_in[4*j+1], dw_in[4*j+2], dw_in[4*j+3]);
        forall j :: 0 < j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
    reads 
        eax;
    modifies
        mem; xmm1; efl;
    ensures
        mem == old(mem)[K_id := mem[K_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[K_id].quads?[a] ==> mem[K_id].quads?[a] && mem[K_id].quads[a] == old(mem)[K_id].quads[a];
        SeqLength(dw_out) == 4*(rounds+1);
        forall j :: 0 <= j <= rounds ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw_out[4*j], dw_out[4*j+1], dw_out[4*j+2], dw_out[4*j+3]);
        forall j :: rounds < j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        EqInvKeyExpansionPredicatePartial(key, AES_128, dw_out, rounds);
{
    inline if (0 < rounds <= 9) {
        ghost var dw_mid;
        dw_mid := KeyInversionRoundUnrolledRecursive(rounds-1, taint, K_id, key, w, dw_in);
        dw_out := KeyInversionRound(rounds-1, taint, K_id, key, w, dw_mid);
    }
    else {
        dw_out := dw_in;
    }
}

procedure {:refined} KeyInversionImpl(
    ghost key:seq(uint32),
    ghost w:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost dw:seq(uint32)
    )
    requires/ensures
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
    requires
        eax % 16 == 0;
        SeqLength(key) == 4;
        SeqLength(w) == 44;
        forall j :: 0 <= j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(w[4*j], w[4*j+1], w[4*j+2], w[4*j+3]);
        KeyExpansionPredicate(key, AES_128, w);
    ensures
        mem == old(mem)[K_id := mem[K_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[K_id].quads?[a] ==> mem[K_id].quads?[a] && mem[K_id].quads[a] == old(mem)[K_id].quads[a];
        SeqLength(dw) == 44;
        EqInvKeyExpansionPredicate(key, AES_128, dw);
        forall j :: 0 <= j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]);
    reads
        eax;
    modifies
        mem; xmm1; efl;
{
    lemma_KeyExpansionPredicateImpliesExpandKey(key, AES_128, w);
    ghost var dw1 := seq(w[0], w[1], w[2], w[3]);

    ghost var dw2;
    dw2 := KeyInversionRoundUnrolledRecursive(9, taint, K_id, key, w, dw1);

    dw := dw2 + seq(w[40], w[41], w[42], w[43]);
    assert SeqLength(dw) == 44;
    forall j :| 0 <= j <= 10 :: mem[K_id].quads[eax + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3])
    {
    }
    assert EqInvKeyExpansionPredicate(key, AES_128, dw);
}

procedure {:refined} KeyExpansionAndInversionStdcall(
    inline taint:taint,
    ghost input_key_id:heaplet_id,
    ghost output_key_expansion_id:heaplet_id
    ) returns (
    ghost dw:seq(uint32)
    )
    reads
        stack;
    modifies
        mem; eax; xmm1; xmm2; xmm3; efl;
    requires
        HasStackSlots(stack, 2);
        let key_ptr := stack[0][0] in
        let key_expansion_ptr := stack[0][1] in
           key_ptr % 16 == 0
        && key_expansion_ptr % 16 == 0
        && ValidSrcAddr(mem, input_key_id, key_ptr, 128, taint)
        && ValidDstAddrs(mem, output_key_expansion_id, key_expansion_ptr, 128, 176);
    ensures
        SeqLength(dw) == 44;
        let key_ptr := old(stack[0][0]) in
        let key_expansion_ptr := old(stack[0][1]) in
        let key := Quadword_to_seq(old(mem)[input_key_id].quads[key_ptr].v) in
           ValidSrcAddrs(mem, output_key_expansion_id, key_expansion_ptr, 128, taint, 176)
        && mem == old(mem)[output_key_expansion_id := mem[output_key_expansion_id]]
        && (forall a :: (a < key_expansion_ptr || a >= key_expansion_ptr + 176) && old(mem)[output_key_expansion_id].quads?[a] ==> mem[output_key_expansion_id].quads?[a] && mem[output_key_expansion_id].quads[a] == old(mem)[output_key_expansion_id].quads[a])
        && (forall j :: 0 <= j <= 10 ==> mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]))
        && EqInvKeyExpansionPredicate(key, AES_128, dw);
{
    ghost var key_ptr := stack[0][0];
    ghost var key_expansion_ptr := stack[0][1];
    ghost var key := Quadword_to_seq(mem[input_key_id].quads[key_ptr].v);

    LoadStack(eax, 0);                                     // eax := key_ptr (from stack position 0)
    Load128(xmm1, eax, 0, taint, input_key_id);            // xmm1 = contents of eax as Quadword ptr
    LoadStack(eax, 1);                                     // eax := key_expansion_ptr (from stack position 1)
    ghost var w;
    w := KeyExpansionImpl(key, taint, output_key_expansion_id); // expand key from xmm1 to region pointed to by eax
    dw := KeyInversionImpl(key, w, taint, output_key_expansion_id);

    forall j :| 0 <= j <= 10 :: mem[output_key_expansion_id].quads[key_expansion_ptr + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3])
    {
        assert mem[output_key_expansion_id].quads[eax + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]);
        assert eax == key_expansion_ptr;
    }

    // Clear secrets out of registers
    Xor32(eax, eax);
    Pxor(xmm1, xmm1);
    Pxor(xmm2, xmm2);
    Pxor(xmm3, xmm3);
}

///////////////////////////
// DECRYPTION
///////////////////////////

procedure {:refined} AES128DecryptFirstStep(
    ghost key:seq(uint32),
    ghost dw:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl;
    requires
        SeqLength(key) == 4;
        SeqLength(dw) == 44;
        ValidSrcAddr(mem, K_id, eax+160, 128, taint);
        mem[K_id].quads[eax+160].v == Quadword(dw[40], dw[41], dw[42], dw[43]);
        EqInvKeyExpansionPredicate(key, AES_128, dw);
    ensures
        SeqLength(xmm0_trace_out) == 1;
        xmm0_trace_out[0] == xmm0;
        IsValidAES128DecryptionTracePrefix(key, dw, old(xmm0), xmm0_trace_out);
{
    // ROUND 0 - XOR

    Load128(xmm2, eax, 160, taint, K_id);
    assert xmm2 == Quadword(dw[40], dw[41], dw[42], dw[43]);

    Pxor(xmm0, xmm2);

    xmm0_trace_out := seq(xmm0);
    assert IsValidAES128DecryptionTracePrefix(key, dw, old(xmm0), xmm0_trace_out);
}

procedure {:refined} AES128DecryptMiddleStep(
    inline round:int,
    ghost key:seq(uint32),
    ghost dw:seq(uint32),
    ghost input:Quadword,
    ghost xmm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl;
    requires
        SeqLength(xmm0_trace_in) == round;
        1 <= round <= 9;
        xmm0_trace_in[round-1] == xmm0;
        IsValidAES128DecryptionTracePrefix(key, dw, input, xmm0_trace_in);
        SeqLength(key) == 4;
        SeqLength(dw) == 44;
        ValidSrcAddr(mem, K_id, eax+16*(10-round), 128, taint);
        mem[K_id].quads[eax+16*(10-round)].v == Quadword(dw[4*(10-round)], dw[4*(10-round)+1], dw[4*(10-round)+2], dw[4*(10-round)+3]);
        EqInvKeyExpansionPredicate(key, AES_128, dw);
    ensures
        SeqLength(xmm0_trace_out) == round + 1;
        xmm0_trace_out[round] == xmm0;
        IsValidAES128DecryptionTracePrefix(key, dw, input, xmm0_trace_out);
{
    ghost var old_xmm0 := xmm0;

    Load128(xmm2, eax, 16*(10-round), taint, K_id);
    //MOVDQU(xmm2, stack(4*(10-round)+12));
    assert xmm2 == seq_to_Quadword(SeqRange(dw, 4*(10-round), 4*(10-round)+4));
    AESNI_dec(xmm0, xmm2);

    ghost var new_xmm0 := xmm0;
    //assert new_xmm0 == xmm_xor(uint32seq_to_XMM(InvMixColumns(InvSubBytes(InvShiftRows(XMM_to_uint32seq(old_xmm0))))), uint32seq_to_XMM(SeqRange(dw, 4*(10-round), 4*(10-round)+4)));
    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);

    //assert XmmsContain(this, 0) && XmmsContain(this, 1) && XmmsContain(this, 2) && XmmsContain(this, 3);

    lemma_ExtendingAES128DecryptionTracePrefix(key, dw, input, round, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
}

procedure {:refined} AES128DecryptLastStep(
    ghost key:seq(uint32),
    ghost dw:seq(uint32),
    ghost input:Quadword,
    ghost xmm0_trace_in:QuadwordSeq,
    inline taint:taint,
    ghost K_id:heaplet_id
    ) returns (
    ghost xmm0_trace_out:QuadwordSeq
    )
    reads
        eax; mem;
    modifies
        xmm0; xmm2; efl;
    requires
        SeqLength(key) == 4;
        SeqLength(dw) == 44;
        ValidSrcAddr(mem, K_id, eax, 128, taint);
        mem[K_id].quads[eax].v == Quadword(dw[0], dw[1], dw[2], dw[3]);
        EqInvKeyExpansionPredicate(key, AES_128, dw);
        SeqLength(xmm0_trace_in) == 10;
        xmm0_trace_in[9] == xmm0;
        IsValidAES128DecryptionTracePrefix(key, dw, input, xmm0_trace_in);
    ensures
        SeqLength(xmm0_trace_out) == 11;
        xmm0_trace_out[10] == xmm0;
        IsValidAES128DecryptionTracePrefix(key, dw, input, xmm0_trace_out);
{
    ghost var old_xmm0 := xmm0;

    Load128(xmm2, eax, 0, taint, K_id);
    assert xmm2 == seq_to_Quadword(SeqRange(dw, 0, 4));
    AESNI_dec_last(xmm0, xmm2);

    ghost var new_xmm0 := xmm0;
    xmm0_trace_out := SeqAppendElt(xmm0_trace_in, new_xmm0);

    lemma_ExtendingAES128DecryptionTracePrefix(key, dw, input, 10, old_xmm0, new_xmm0, xmm0_trace_in, xmm0_trace_out);
    assert IsValidAES128DecryptionTracePrefix(key, dw, input, xmm0_trace_out);
}

procedure {:refined} AES128DecryptOneBlock(
    ghost key:seq(uint32),
    ghost input:Quadword,
    ghost dw:seq(uint32),
    inline taint:taint,
    ghost K_id:heaplet_id
    )
    reads
        mem; eax; 
    modifies
        xmm0; xmm2; efl;
    requires
        eax % 16 == 0;
        SeqLength(key) == 4;
        xmm0 == input;
        SeqLength(dw) == 44;
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
        forall j :: 0 <= j <= 10 ==> mem[K_id].quads[eax + 16*j].v == Quadword(dw[4*j], dw[4*j+1], dw[4*j+2], dw[4*j+3]);
        EqInvKeyExpansionPredicate(key, AES_128, dw);
    ensures
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
        xmm0 == AES_EquivDecrypt(key, input, AES_128);
{
    ghost var xmm0_trace_step0:QuadwordSeq := seq(xmm0);
    xmm0_trace_step0 := AES128DecryptFirstStep(key, dw, taint, K_id);
    assert mem[K_id].quads[eax + 16*10].v == Quadword(dw[4*10], dw[4*10+1], dw[4*10+2], dw[4*10+3]);

    assert mem[K_id].quads[eax + 16* 9].v == Quadword(dw[4* 9], dw[4* 9+1], dw[4* 9+2], dw[4* 9+3]);
    ghost var xmm0_trace_step1:QuadwordSeq;
    xmm0_trace_step1 := AES128DecryptMiddleStep(1, key, dw, input, xmm0_trace_step0, taint, K_id);

    assert mem[K_id].quads[eax + 16* 8].v == Quadword(dw[4* 8], dw[4* 8+1], dw[4* 8+2], dw[4* 8+3]);
    ghost var xmm0_trace_step2:QuadwordSeq;
    xmm0_trace_step2 := AES128DecryptMiddleStep(2, key, dw, input, xmm0_trace_step1, taint, K_id);

    assert mem[K_id].quads[eax + 16* 7].v == Quadword(dw[4* 7], dw[4* 7+1], dw[4* 7+2], dw[4* 7+3]);
    ghost var xmm0_trace_step3:QuadwordSeq;
    xmm0_trace_step3 := AES128DecryptMiddleStep(3, key, dw, input, xmm0_trace_step2, taint, K_id);

    assert mem[K_id].quads[eax + 16* 6].v == Quadword(dw[4* 6], dw[4* 6+1], dw[4* 6+2], dw[4* 6+3]);
    ghost var xmm0_trace_step4:QuadwordSeq;
    xmm0_trace_step4 := AES128DecryptMiddleStep(4, key, dw, input, xmm0_trace_step3, taint, K_id);

    assert mem[K_id].quads[eax + 16* 5].v == Quadword(dw[4* 5], dw[4* 5+1], dw[4* 5+2], dw[4* 5+3]);
    ghost var xmm0_trace_step5:QuadwordSeq;
    xmm0_trace_step5 := AES128DecryptMiddleStep(5, key, dw, input, xmm0_trace_step4, taint, K_id);

    assert mem[K_id].quads[eax + 16* 4].v == Quadword(dw[4* 4], dw[4* 4+1], dw[4* 4+2], dw[4* 4+3]);
    ghost var xmm0_trace_step6:QuadwordSeq;
    xmm0_trace_step6 := AES128DecryptMiddleStep(6, key, dw, input, xmm0_trace_step5, taint, K_id);

    assert mem[K_id].quads[eax + 16* 3].v == Quadword(dw[4* 3], dw[4* 3+1], dw[4* 3+2], dw[4* 3+3]);
    ghost var xmm0_trace_step7:QuadwordSeq;
    xmm0_trace_step7 := AES128DecryptMiddleStep(7, key, dw, input, xmm0_trace_step6, taint, K_id);

    assert mem[K_id].quads[eax + 16* 2].v == Quadword(dw[4* 2], dw[4* 2+1], dw[4* 2+2], dw[4* 2+3]);
    ghost var xmm0_trace_step8:QuadwordSeq;
    xmm0_trace_step8 := AES128DecryptMiddleStep(8, key, dw, input, xmm0_trace_step7, taint, K_id);

    assert mem[K_id].quads[eax + 16* 1].v == Quadword(dw[4* 1], dw[4* 1+1], dw[4* 1+2], dw[4* 1+3]);
    ghost var xmm0_trace_step9:QuadwordSeq;
    xmm0_trace_step9 := AES128DecryptMiddleStep(9, key, dw, input, xmm0_trace_step8, taint, K_id);

    assert mem[K_id].quads[eax + 16* 0].v == Quadword(dw[4* 0], dw[4* 0+1], dw[4* 0+2], dw[4* 0+3]);
    ghost var xmm0_trace_step10:QuadwordSeq;
    xmm0_trace_step10 := AES128DecryptLastStep(key, dw, input, xmm0_trace_step9, taint, K_id);

    lemma_AES128Decrypt(key, input, dw, xmm0, xmm0_trace_step10);
    assert (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
    assert (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
    assert xmm0 == AES_EquivDecrypt(key, input, AES_128);

    // Clear secrets out of registers
    Pxor(xmm2, xmm2);
}

procedure {:refined} AES128ExpandKeyAndDecryptOneBlock(
    ghost key:seq(uint32),
    ghost input:Quadword,
    inline taint:taint,
    ghost K_id:heaplet_id
    )
    reads
        eax;
    modifies
        mem; xmm0; xmm1; xmm2; xmm3; efl;
    requires
        SeqLength(key) == 4;
        xmm0 == input;
        xmm1 == seq_to_Quadword(key);
        eax % 16 == 0;
        ValidDstAddrs(mem, K_id, eax, 128, 16*11);
    ensures
        ValidSrcAddrs(mem, K_id, eax, 128, taint, 16*11);
        mem == old(mem)[K_id := mem[K_id]];
        forall a :: (a < eax || a >= eax + 176) && old(mem)[K_id].quads?[a] ==> mem[K_id].quads?[a] && mem[K_id].quads[a] == old(mem)[K_id].quads[a];
        (Nb() * (Nr(AES_128) + 1)) / 4 == Nr(AES_128) + 1;
        (Nb() * (Nr(AES_128) + 1)) % 4 == 0;
        xmm0 == AES_EquivDecrypt(key, input, AES_128);
{
    ghost var w;
    w := KeyExpansionImpl(key, taint, K_id);

    ghost var dw;
    dw := KeyInversionImpl(key, w, taint, K_id);

    AES128DecryptOneBlock(key, input, dw, taint, K_id);
}

#verbatim
} // end module aes_vale
#endverbatim
